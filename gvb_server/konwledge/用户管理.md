## 命令行创建用户

当我们刚接触这个项目是没有用户的，所以可以采取命令行创建用户的方式，例如

在flag中书写

```go
package flag

import sys_flag "flag"

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) bool {
  //在创建数据库时停下
  if option.DB {
    return true
  }
  //在命令行创建用户时停下
  if option.User =="admin"||option.User =="user"{
    return true
  }
  return false
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //不符合预期走这里
  sys_flag.Usage()
}
```

创建用户的逻辑

```go
package flag

import (
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/utils"
)

func CreateUser(permissions string) {
	// 创建用户的逻辑
	// 用户名 昵称 密码 确认密码 邮箱
	var (
		userName   string
		nickName   string
		password   string
		rePassword string
		email      string
	)
	//先打印再输入
	//Scan要求必须输入，Scanln可以通过回车换行来避免输入
	fmt.Printf("请输入用户名：")
	fmt.Scan(&userName)
	fmt.Printf("请输入昵称：")
	fmt.Scan(&nickName)
	fmt.Printf("请输入邮箱：")
	fmt.Scan(&email)
	fmt.Printf("请输入密码：")
	fmt.Scan(&password)
	fmt.Printf("请再次输入密码：")
	fmt.Scan(&rePassword)

	// 判断用户名是否存在
	var userModel models.UserModel
	count := global.DB.Take(&userModel, "user_name = ?", userName).RowsAffected
	if count > 0 {
		// 存在
		global.Log.Error("用户名已存在，请重新输入")
		return
	}
	// 校验两次密码
	if password != rePassword {
		global.Log.Error("两次密码不一致，请重新输入")
		return
	}
	// 对密码进行hash
	hashPwd := utils.HashPwd(password)

	role := ctype.PermissionUser
	if permissions == "admin" {
		role = ctype.PermissionAdmin
	}

	// 头像问题
	// 1. 默认头像
	// 2. 随机选择头像
	avatar := "/uploads/avatar/default.jpg"

	// 入库
	err := global.DB.Create(&models.UserModel{
		NickName:   nickName,
		UserName:   userName,
		Password:   hashPwd,
		Email:      email,
		Role:       role,
		Avatar:     avatar,
		IP:         "127.0.0.1",
		Addr:       "内网地址",
		SignStatus: ctype.SignEmail,
	}).Error
	if err != nil {
		global.Log.Error(err)
		return
	}
	global.Log.Infof("用户%s创建成功!", userName)

}
```

书写pwd的工具类

```go
package utils

//密码加密
import (
    "fmt"
    "log"
    "golang.org/x/crypto/bcrypt"
)
 
func getPwd() []byte {
    fmt.Println("Enter a password")
    var pwd string
    _, err := fmt.Scan(&pwd)
    if err != nil {
        log.Println(err)
    }
    return []byte(pwd)
}

//hash密码
func HashPwd(pwd string) string {
    hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.MinCost)
    if err != nil {
        log.Println(err)
    }
    return string(hash)
}


//验证密码 hash之后的密码 输入的密码
func CheckPwd(hashPwd string, pwd string) bool {
    byteHash := []byte(hashPwd)
 
    err := bcrypt.CompareHashAndPassword(byteHash, []byte(pwd))
    if err != nil {
        log.Println(err)
        return false
    }
    return true
}
```

书写对应的测试用例`pwd_test.go`

```go
package testdata

import (
	"fmt"
	"gvb_server/utils"
	"testing"
)

func TestHashPwd(t *testing.T) {
	fmt.Printf(utils.HashPwd("1234"))
}

func TestCheckPwd(t *testing.T) {
	var str = utils.HashPwd("1234")
	fmt.Println(utils.CheckPwd(str,"1234"))
}
```

待优化的问题:

```sh
对于一些不想传的参数，怎么处理
fmt.Scanln除了在第一个，后面的都会马上赋值
```

### 对于web项目是否停止的优化

```go
// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}
```

优化后

```go
package flag

import (
	sys_flag "flag"
	"github.com/fatih/structs"
)

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //不符合预期走这里
  sys_flag.Usage()
}
```



## 用户登录

### JWT的实现

JWT（json web token），它并不是一个具体的技术实现，而更像是一种标准。

JWT规定了数据传输的结构，一串完整的JWT由三段落组成，每个段落用英文句号连接（.）连接，他们分别是：Header、Payload、Signature，所以，常规的JWT内容格式是这样的：AAA.BBB.CCC

并且，这一串内容会base64加密；也就是说base64解码就可以看到实际传输的内容。接下来解释一下这些内容都有什么作用。

常用的go实现jwt的包

```sh
https://github.com/dgrijalva/jwt-go
```

本项目中使用版本

```go
go get "github.com/dgrijalva/jwt-go/v4"
```

**jwt工具类**

```go
package jwt

import (
	"errors"
	"fmt"
	"gvb_server/global"
	"time"

	"github.com/dgrijalva/jwt-go/v4"
)

// JwtPayLoad jwt中payload数据
type JwtPayLoad struct {
	Username string `json:"username"` // 用户名
	NickName string `json:"nickName"` // 昵称
	Role     int    `json:"role"`      // 权限  1 管理员  2 普通用户  3 游客
	UserID   uint   `json:"userId"`   // 用户id
  }
  
  type CustomClaims struct {
	JwtPayLoad
	jwt.StandardClaims
  }
  
  
  // GenToken 创建 Token
  func GenToken(user JwtPayLoad) (string, error) {
	MySecret := []byte(global.Config.Jwt.Secret)
	claim := CustomClaims{
	  user,
	  jwt.StandardClaims{
        // 默认2小时过期
		ExpiresAt: jwt.At(time.Now().Add(time.Hour * time.Duration(global.Config.Jwt.Expires))), 
        // 签发人
		Issuer:    global.Config.Jwt.Issuer,                                                     
	  },
	}
  
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)
	return token.SignedString(MySecret)
  }
  
  // ParseToken 解析 token
  func ParseToken(tokenStr string) (*CustomClaims, error) {
	MySecret := []byte(global.Config.Jwt.Secret)
	token, err := jwt.ParseWithClaims(tokenStr, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
	  return MySecret, nil
	})
	if err != nil {
	  global.Log.Error(fmt.Sprintf("token parse err: %s", err.Error()))
	  return nil, err
	}
	if claims, ok := token.Claims.(*CustomClaims); ok && token.Valid {
	  return claims, nil
	}
	return nil, errors.New("invalid token")
  }
```

**测试**

这个测试走不通，因为无法读取到全局变量global

```go
package testdata

import (
	"fmt"
	"gvb_server/global"
	"gvb_server/utils/jwt"
	"testing"
)
func TestJwt(t *testing.T) {

	fmt.Println(global.Config)

	token,err:=jwt.GenToken(jwt.JwtPayLoad{
		UserID: 1,
		Role: 1,
		Username: "upsilon",
		NickName: "lmryBC01",
	})

	fmt.Printf(token,err)
}
```

解决方案，提供一个剥离global的方法来测试，例如

```go
package jwt

import (
	"errors"
	"fmt"
	"gvb_server/global"
	"time"

	"github.com/dgrijalva/jwt-go/v4"
)

// JwtPayLoad jwt中payload数据
type JwtPayLoad struct {
	Username string `json:"username"` // 用户名
	NickName string `json:"nickName"` // 昵称
	Role     int    `json:"role"`      // 权限  1 管理员  2 普通用户  3 游客
	UserID   uint   `json:"userId"`   // 用户id
  }
  
  type CustomClaims struct {
	JwtPayLoad
	jwt.StandardClaims
  }
  
  //配合测试使用
  func GenTokenforTest(user JwtPayLoad) (string, error) {
	MySecret := []byte("xxxx")
	claim := CustomClaims{
	  user,
	  jwt.StandardClaims{
		ExpiresAt: jwt.At(time.Now().Add(time.Hour * time.Duration(48))), // 默认2小时过期
		Issuer:    "xxx",                                                     // 签发人
	  },
	}
  
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)
	return token.SignedString(MySecret)
  }
```

测试方法书写，其实测试的方法也可以写在该包下，更具有可读性

```go
package jwt

import (
	"fmt"
	"testing"
)
func TestJwt(t *testing.T) {
	//由于token需要配置文件，所以我们要提前加载
	//如果不加载会报错invalid memory address or nil pointer dereference
	// core.InitConf()
	// global.Log = core.InitLogger()
	token,err:=GenTokenforTest(JwtPayLoad{
		UserID: 1,
		Role: 1,
		Username: "upsilon",
		NickName: "lmryBC01",
	})

	fmt.Printf(token,err)
}
```

### 邮箱登录

```go
package user_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/utils"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

type EmailLoginRequest struct {
	UserName string `json:"userName" binding:"required" msg:"请输入用户名"`
	Password string `json:"password" binding:"required" msg:"请输入密码"`
}

func (UserApi) EmailLoginView(c *gin.Context) {
	var cr EmailLoginRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}


	//验证用户是否存在
	var userModel models.UserModel
	//我们页面上传入的用户名、邮箱等实际上都被cr.UserName接收
	count := global.DB.Take(&userModel, "user_name = ? or email = ?", cr.UserName, cr.UserName).RowsAffected
	if count == 0 {
		// 没找到
		global.Log.Warn("用户名不存在")
		res.FailWithMessage("用户名不存在", c)
		return
	}
	// 校验密码
	isCheck := utils.CheckPwd(userModel.Password, cr.Password)
	if !isCheck {
		global.Log.Warn("用户名密码错误")
		res.FailWithMessage("用户密码错误", c)
		return
	}
	// 登录成功，生成token
	token, err := jwts.GenToken(jwts.JwtPayLoad{
		NickName: userModel.NickName,
		Role:     int(userModel.Role),
		UserID:   userModel.ID,
	})
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("token生成失败", c)
		return
	}
	res.OkWithData(token, c)

}
```

## 用户列表

### 基础用户列表获取

```go
func (UserApi) UserListView(c *gin.Context) {
	//分页获取用户列表数据
	var page models.PageInfo
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
	})

	res.OkWithList(users, count, c)
}
```

如果我们想要返回列表时不展示某个字段，例如密码，就可以在model里把对应解析设为忽略

```go
// UserModel 用户表
type UserModel struct {
	// gorm.Model //如果想要使用逻辑删除就用这个
	MODEL
	NickName   string           `gorm:"size:36" json:"nickName,select(c)"`  // 昵称
	UserName   string           `gorm:"size:36" json:"userName"`            // 用户名
    //忽略了密码，那么解析时就不会返回密码
	Password   string           `gorm:"size:128" json:"-"`                   // 密码
	Avatar     string           `gorm:"size:256" json:"avatar,select(c)"`    // 头像id
	Email      string           `gorm:"size:128" json:"email"`               // 邮箱
	Tel        string           `gorm:"size:18" json:"tel"`                  // 手机号
	Addr       string           `gorm:"size:64" json:"addr,select(c)"`       // 地址
	Token      string           `gorm:"size:64" json:"token"`                // 其他平台的唯一id
	IP         string           `gorm:"size:20" json:"ip,select(c)"`         // ip地址
	Role       ctype.Role       `gorm:"size:4;default:1" json:"role"`        // 权限  1 管理员  2 普通用户  3 游客
	SignStatus ctype.SignStatus `gorm:"type=smallint(6)" json:"signStatus"` // 注册来源
}
```



