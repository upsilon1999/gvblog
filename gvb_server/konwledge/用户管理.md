## 命令行创建用户

当我们刚接触这个项目是没有用户的，所以可以采取命令行创建用户的方式，例如

在flag中书写

```go
package flag

import sys_flag "flag"

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) bool {
  //在创建数据库时停下
  if option.DB {
    return true
  }
  //在命令行创建用户时停下
  if option.User =="admin"||option.User =="user"{
    return true
  }
  return false
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //不符合预期走这里
  sys_flag.Usage()
}
```

创建用户的逻辑

```go
package flag

import (
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/utils"
)

func CreateUser(permissions string) {
	// 创建用户的逻辑
	// 用户名 昵称 密码 确认密码 邮箱
	var (
		userName   string
		nickName   string
		password   string
		rePassword string
		email      string
	)
	//先打印再输入
	//Scan要求必须输入，Scanln可以通过回车换行来避免输入
	fmt.Printf("请输入用户名：")
	fmt.Scan(&userName)
	fmt.Printf("请输入昵称：")
	fmt.Scan(&nickName)
	fmt.Printf("请输入邮箱：")
	fmt.Scan(&email)
	fmt.Printf("请输入密码：")
	fmt.Scan(&password)
	fmt.Printf("请再次输入密码：")
	fmt.Scan(&rePassword)

	// 判断用户名是否存在
	var userModel models.UserModel
	count := global.DB.Take(&userModel, "user_name = ?", userName).RowsAffected
	if count > 0 {
		// 存在
		global.Log.Error("用户名已存在，请重新输入")
		return
	}
	// 校验两次密码
	if password != rePassword {
		global.Log.Error("两次密码不一致，请重新输入")
		return
	}
	// 对密码进行hash
	hashPwd := utils.HashPwd(password)

	role := ctype.PermissionUser
	if permissions == "admin" {
		role = ctype.PermissionAdmin
	}

	// 头像问题
	// 1. 默认头像
	// 2. 随机选择头像
	avatar := "/uploads/avatar/default.jpg"

	// 入库
	err := global.DB.Create(&models.UserModel{
		NickName:   nickName,
		UserName:   userName,
		Password:   hashPwd,
		Email:      email,
		Role:       role,
		Avatar:     avatar,
		IP:         "127.0.0.1",
		Addr:       "内网地址",
		SignStatus: ctype.SignEmail,
	}).Error
	if err != nil {
		global.Log.Error(err)
		return
	}
	global.Log.Infof("用户%s创建成功!", userName)

}
```

书写pwd的工具类

```go
package utils

//密码加密
import (
    "fmt"
    "log"
    "golang.org/x/crypto/bcrypt"
)
 
func getPwd() []byte {
    fmt.Println("Enter a password")
    var pwd string
    _, err := fmt.Scan(&pwd)
    if err != nil {
        log.Println(err)
    }
    return []byte(pwd)
}

//hash密码
func HashPwd(pwd string) string {
    hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.MinCost)
    if err != nil {
        log.Println(err)
    }
    return string(hash)
}


//验证密码 hash之后的密码 输入的密码
func CheckPwd(hashPwd string, pwd string) bool {
    byteHash := []byte(hashPwd)
 
    err := bcrypt.CompareHashAndPassword(byteHash, []byte(pwd))
    if err != nil {
        log.Println(err)
        return false
    }
    return true
}
```

书写对应的测试用例`pwd_test.go`

```go
package testdata

import (
	"fmt"
	"gvb_server/utils"
	"testing"
)

func TestHashPwd(t *testing.T) {
	fmt.Printf(utils.HashPwd("1234"))
}

func TestCheckPwd(t *testing.T) {
	var str = utils.HashPwd("1234")
	fmt.Println(utils.CheckPwd(str,"1234"))
}
```

待优化的问题:

```sh
对于一些不想传的参数，怎么处理
fmt.Scanln除了在第一个，后面的都会马上赋值
```

### 对于web项目是否停止的优化

```go
// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}
```

优化后

```go
package flag

import (
	sys_flag "flag"
	"github.com/fatih/structs"
)

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //不符合预期走这里
  sys_flag.Usage()
}
```



## 用户登录

### JWT的实现

JWT（json web token），它并不是一个具体的技术实现，而更像是一种标准。

JWT规定了数据传输的结构，一串完整的JWT由三段落组成，每个段落用英文句号连接（.）连接，他们分别是：Header、Payload、Signature，所以，常规的JWT内容格式是这样的：AAA.BBB.CCC

并且，这一串内容会base64加密；也就是说base64解码就可以看到实际传输的内容。接下来解释一下这些内容都有什么作用。

常用的go实现jwt的包

```sh
https://github.com/dgrijalva/jwt-go
```

本项目中使用版本

```go
go get "github.com/dgrijalva/jwt-go/v4"
```

**jwt工具类**

```go
package jwt

import (
	"errors"
	"fmt"
	"gvb_server/global"
	"time"

	"github.com/dgrijalva/jwt-go/v4"
)

// JwtPayLoad jwt中payload数据
type JwtPayLoad struct {
	Username string `json:"username"` // 用户名
	NickName string `json:"nickName"` // 昵称
	Role     int    `json:"role"`      // 权限  1 管理员  2 普通用户  3 游客
	UserID   uint   `json:"userId"`   // 用户id
  }
  
  type CustomClaims struct {
	JwtPayLoad
	jwt.StandardClaims
  }
  
  
  // GenToken 创建 Token
  func GenToken(user JwtPayLoad) (string, error) {
	MySecret := []byte(global.Config.Jwt.Secret)
	claim := CustomClaims{
	  user,
	  jwt.StandardClaims{
        // 默认2小时过期
		ExpiresAt: jwt.At(time.Now().Add(time.Hour * time.Duration(global.Config.Jwt.Expires))), 
        // 签发人
		Issuer:    global.Config.Jwt.Issuer,                                                     
	  },
	}
  
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)
	return token.SignedString(MySecret)
  }
  
  // ParseToken 解析 token
  func ParseToken(tokenStr string) (*CustomClaims, error) {
	MySecret := []byte(global.Config.Jwt.Secret)
	token, err := jwt.ParseWithClaims(tokenStr, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
	  return MySecret, nil
	})
	if err != nil {
	  global.Log.Error(fmt.Sprintf("token parse err: %s", err.Error()))
	  return nil, err
	}
	if claims, ok := token.Claims.(*CustomClaims); ok && token.Valid {
	  return claims, nil
	}
	return nil, errors.New("invalid token")
  }
```

**测试**

这个测试走不通，因为无法读取到全局变量global

```go
package testdata

import (
	"fmt"
	"gvb_server/global"
	"gvb_server/utils/jwt"
	"testing"
)
func TestJwt(t *testing.T) {

	fmt.Println(global.Config)

	token,err:=jwt.GenToken(jwt.JwtPayLoad{
		UserID: 1,
		Role: 1,
		Username: "upsilon",
		NickName: "lmryBC01",
	})

	fmt.Printf(token,err)
}
```

解决方案，提供一个剥离global的方法来测试，例如

```go
package jwt

import (
	"errors"
	"fmt"
	"gvb_server/global"
	"time"

	"github.com/dgrijalva/jwt-go/v4"
)

// JwtPayLoad jwt中payload数据
type JwtPayLoad struct {
	Username string `json:"username"` // 用户名
	NickName string `json:"nickName"` // 昵称
	Role     int    `json:"role"`      // 权限  1 管理员  2 普通用户  3 游客
	UserID   uint   `json:"userId"`   // 用户id
  }
  
  type CustomClaims struct {
	JwtPayLoad
	jwt.StandardClaims
  }
  
  //配合测试使用
  func GenTokenforTest(user JwtPayLoad) (string, error) {
	MySecret := []byte("xxxx")
	claim := CustomClaims{
	  user,
	  jwt.StandardClaims{
		ExpiresAt: jwt.At(time.Now().Add(time.Hour * time.Duration(48))), // 默认2小时过期
		Issuer:    "xxx",                                                     // 签发人
	  },
	}
  
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)
	return token.SignedString(MySecret)
  }
```

测试方法书写，其实测试的方法也可以写在该包下，更具有可读性

```go
package jwt

import (
	"fmt"
	"testing"
)
func TestJwt(t *testing.T) {
	//由于token需要配置文件，所以我们要提前加载
	//如果不加载会报错invalid memory address or nil pointer dereference
	// core.InitConf()
	// global.Log = core.InitLogger()
	token,err:=GenTokenforTest(JwtPayLoad{
		UserID: 1,
		Role: 1,
		Username: "upsilon",
		NickName: "lmryBC01",
	})

	fmt.Printf(token,err)
}
```

### 邮箱登录

```go
package user_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/utils"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

type EmailLoginRequest struct {
	UserName string `json:"userName" binding:"required" msg:"请输入用户名"`
	Password string `json:"password" binding:"required" msg:"请输入密码"`
}

func (UserApi) EmailLoginView(c *gin.Context) {
	var cr EmailLoginRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}


	//验证用户是否存在
	var userModel models.UserModel
	//我们页面上传入的用户名、邮箱等实际上都被cr.UserName接收
	count := global.DB.Take(&userModel, "user_name = ? or email = ?", cr.UserName, cr.UserName).RowsAffected
	if count == 0 {
		// 没找到
		global.Log.Warn("用户名不存在")
		res.FailWithMessage("用户名不存在", c)
		return
	}
	// 校验密码
	isCheck := utils.CheckPwd(userModel.Password, cr.Password)
	if !isCheck {
		global.Log.Warn("用户名密码错误")
		res.FailWithMessage("用户密码错误", c)
		return
	}
	// 登录成功，生成token
	token, err := jwts.GenToken(jwts.JwtPayLoad{
		NickName: userModel.NickName,
		Role:     int(userModel.Role),
		UserID:   userModel.ID,
	})
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("token生成失败", c)
		return
	}
	res.OkWithData(token, c)

}
```

## 用户列表

### 基础用户列表获取

```go
func (UserApi) UserListView(c *gin.Context) {
	//分页获取用户列表数据
	var page models.PageInfo
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
	})

	res.OkWithList(users, count, c)
}
```

如果我们想要返回列表时不展示某个字段，例如密码，就可以在model里把对应解析设为忽略

```go
// UserModel 用户表
type UserModel struct {
	// gorm.Model //如果想要使用逻辑删除就用这个
	MODEL
	NickName   string           `gorm:"size:36" json:"nickName,select(c)"`  // 昵称
	UserName   string           `gorm:"size:36" json:"userName"`            // 用户名
    //忽略了密码，那么解析时就不会返回密码
	Password   string           `gorm:"size:128" json:"-"`                   // 密码
	Avatar     string           `gorm:"size:256" json:"avatar,select(c)"`    // 头像id
	Email      string           `gorm:"size:128" json:"email"`               // 邮箱
	Tel        string           `gorm:"size:18" json:"tel"`                  // 手机号
	Addr       string           `gorm:"size:64" json:"addr,select(c)"`       // 地址
	Token      string           `gorm:"size:64" json:"token"`                // 其他平台的唯一id
	IP         string           `gorm:"size:20" json:"ip,select(c)"`         // ip地址
	Role       ctype.Role       `gorm:"size:4;default:1" json:"role"`        // 权限  1 管理员  2 普通用户  3 游客
	SignStatus ctype.SignStatus `gorm:"type=smallint(6)" json:"signStatus"` // 注册来源
}
```

### 判断是否超级管理员

通过解析token来获取访问者身份

```go
package user_api

import (
	"fmt"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"gvb_server/service/common"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (UserApi) UserListView(c *gin.Context) {
	// 如何判断是管理员
	//1.从请求头获取token，没得到就是空字符串
	token := c.Request.Header.Get("token")
	fmt.Println(token)
	//2.如果token为空字符串代表没有token，不应该放行
	if token == "" {
		res.FailWithMessage("未携带token", c)
		return
	}
	//3.解析token
	claims, err := jwts.ParseToken(token)
	//解析出错
	if err != nil {
		res.FailWithMessage("token错误", c)
		return
	}
	//解析成功后的token数据
    fmt.Println(claims)
	//4.如果是超级管理员如何如何
	if claims.Role == "admin"{

	}

	//分页获取用户列表数据
	var page models.PageInfo
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
	})

	res.OkWithList(users, count, c)
}
```

具体会从token中获得哪些数据需要看token的设计，token就是对某个字符串或map进行了加密，解密后当成对应类容处理即可

我们可以利用不同角色来实现不同功能，例如如果不是管理员就无法查看到userName

```go
package user_api

import (
	"fmt"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"gvb_server/service/common"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (UserApi) UserListView(c *gin.Context) {
	// 如何判断是管理员
	//1.从请求头获取token，没得到就是空字符串
	token := c.Request.Header.Get("token")
	fmt.Println(token)
	//2.如果token为空字符串代表没有token，不应该放行
	if token == "" {
		res.FailWithMessage("未携带token", c)
		return
	}
	//3.解析token
	claims, err := jwts.ParseToken(token)
	//解析出错
	if err != nil {
		res.FailWithMessage("token错误", c)
		return
	}
	//解析成功后的token数据
    fmt.Println(claims)

	//分页获取用户列表数据
	var page models.PageInfo
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
	})
	for _, user := range list {
		if ctype.Role(claims.Role) != ctype.PermissionAdmin {
			// 如果不是管理员，就不能看到userName
			user.UserName = ""
		}
		users = append(users, user)
	}

	res.OkWithList(users, count, c)
}
```



### 根据权限对数据进行脱敏

**什么是脱敏**

```sh
脱敏指的是我们把数据从数据库拿出来后，对于敏感数据要进行混淆处理再返回给前端
例如数据库存储为18825540000，返回给前端为188 **** 0000
```

**手机号脱敏**

```go
// 手机号脱敏
//就是将手机号加入星号返回给前端显示
func DesensitizationTel(tel string)string  {
	//这里还可以加入区号的操作，主要看数据库里如何存储
	/*
		
	*/


	//例如正常手机号 18825540000
	//脱敏后为 188 **** 0000
	
	//先判断手机号位数，如果不是11位就返回空
	if len(tel) != 11{
		return ""
	}

	// 然后对手机号进行操作
	return tel[:3]+"****"+tel[7:]
}
```

**邮箱脱敏**

```go
func DesensitizationEmail(email string)  string{
	//根据个人需求，我们的目标保留首字母和邮箱后缀
	//12457@qq.com== 1*****@qq.com
	elist := strings.Split(email, "@")

	//如果有一部分不存在
	if len(elist) != 2{
		return ""
	}
	return elist[0][:1]+"****@"+elist[1]

}
```

### 较完整案例

```go
package user_api

import (
	"fmt"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"gvb_server/service/common"
	"gvb_server/utils"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (UserApi) UserListView(c *gin.Context) {
	// 如何判断是管理员
	//1.从请求头获取token，没得到就是空字符串
	token := c.Request.Header.Get("token")
	fmt.Println(token)
	//2.如果token为空字符串代表没有token，不应该放行
	if token == "" {
		res.FailWithMessage("未携带token", c)
		return
	}
	//3.解析token
	claims, err := jwts.ParseToken(token)
	//解析出错
	if err != nil {
		res.FailWithMessage("token错误", c)
		return
	}
	//解析成功后的token数据
    fmt.Println(claims)

	//分页获取用户列表数据
	var page models.PageInfo
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
	})
	for _, user := range list {
		if ctype.Role(claims.Role) != ctype.PermissionAdmin {
			// 如果不是管理员，就不能看到userName
			user.UserName = ""
		}
		user.Tel = utils.DesensitizationTel(user.Tel)
		user.Email = utils.DesensitizationEmail(user.Email)
		// 脱敏
		users = append(users, user)
	}

	res.OkWithList(users, count, c)
}
```

## 用户登录中间件

很多页面应该都需要token或者某些权限才能访问，如果每个接口都需要写token解析或权限校验就会特别繁琐，所以我们加入中间件的概念，

gin的中间件的基本格式

```go
//返回一个gin.HandlerFunc函数
func 中间件函数名()  gin.HandlerFunc{
    //通过上下文来获取数据
    return func(c *gin.Context){
        //拦截方法
        c.Abort()
        //设置键值对，类似前端存缓存
        c.Set(键,值)
    }
}
```

我们来看源代码

```go
func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {
	if matched := regEnLetter.MatchString(httpMethod); !matched {
		panic("http method " + httpMethod + " is not valid")
	}
	return group.handle(httpMethod, relativePath, handlers)
}

func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
	return group.handle(http.MethodGet, relativePath, handlers)
}
```

中间件都是前验的，因为后验我们可以直接封装方法来实现

如何使用中间件，

```go
1.路由中加入中间件函数
//语法
//路由.HttpMethod(path,中间件函数1，中间件函数2,...,最终响应回调)
//理解：本质上都是回调函数，执行顺序从前往后
router.GET("list",UserApi.UserListView,middleware.JwtAuth())

2.从上下文进行读取
/*
所谓中间件就在做两件事
1.在规则中进行Abort拦截，不再往下执行
2.通过上下文传递内容或者对前端数据进行加工，例如c.Set(键,值)
*/
func (UserApi)UserListView(c *gin.Context){
    //用Get从上下文中取值。语法
    // 值,err := c.Get(键)
    //Get返回的值类型是any，所以要进行类型断言，例如
    _claims,_ := c.Get("claims")
    fmt.Println("token是",_claims)
	//由于Get获取的值是any类型，所以要进行类型断言
	claims := _claims.(*jwts.CustomClaims)
}
```

**判断是否携带token**

```go
//判断是否携带token的中间件
func JwtAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.Request.Header.Get("token")
		if token == "" {
			res.FailWithMessage("未携带token", c)
			c.Abort()
			return
		}
		claims, err := jwts.ParseToken(token)
		if err != nil {
			res.FailWithMessage("token错误", c)
			c.Abort()
			return
		}
		// 登录的用户
		c.Set("claims", claims)
	}
}
```

**管理员才能使用的中间件**

```go
package middleware

import (
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

//管理员才可使用的中间件
func JwtAdmin() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.Request.Header.Get("token")
		if token == "" {
			res.FailWithMessage("未携带token", c)
			c.Abort()
			return
		}
		claims, err := jwts.ParseToken(token)
		if err != nil {
			res.FailWithMessage("token错误", c)
			c.Abort()
			return
		}
		// 登录的用户
		if claims.Role != int(ctype.PermissionAdmin) {
			res.FailWithMessage("权限错误", c)
			c.Abort()
			return
		}
		c.Set("claims", claims)
	}
}
```

### 完整案例

路由加入中间件

```go
package routers

import (
	"gvb_server/api"
	"gvb_server/middleware"
)

//获取siteInfo配置信息
func (router RouterGroup) UserRouter() {
	UserApi:= api.ApiGroupApp.UserApi
	user := router.Group("user")
	{
	   //邮箱或用户名登录
	   user.POST("emailLogin", UserApi.EmailLoginView)
	   //获取用户列表
	   user.GET("list",middleware.JwtAuth(),UserApi.UserListView)
	}
   
  }
```

api层处理

```go
package user_api

import (
	"fmt"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"gvb_server/service/common"
	"gvb_server/utils"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (UserApi) UserListView(c *gin.Context) {
    //获取从中间件来的数据
	_claims,_ := c.Get("claims")
    fmt.Println("token是",_claims)
	//由于Get获取的值是any类型，所以要进行类型断言
	claims := _claims.(*jwts.CustomClaims)
	//分页获取用户列表数据
	var page models.PageInfo
	//前端必须得传limit，即条数，因为现在gorm默认limit为0
	if err := c.ShouldBindQuery(&page); err != nil {
		res.FailWithCode(res.ArgumentError, c)
		return
	}
	var users []models.UserModel
	list, count, _ := common.ComList(models.UserModel{}, common.Option{
		PageInfo: page,
		Debug: true,
	})
	fmt.Println(list)
	for _, user := range list {
		if ctype.Role(claims.Role) != ctype.PermissionAdmin {
			// 如果不是管理员，就不能看到userName
			user.UserName = ""
		}
		user.Tel = utils.DesensitizationTel(user.Tel)
		user.Email = utils.DesensitizationEmail(user.Email)
		// 脱敏
		users = append(users, user)
	}

	res.OkWithList(users, count, c)
}
```

