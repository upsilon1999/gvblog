# ES在本项目中应用

yaml配置文件，`settings.yaml`

```yaml
es:
  #es服务地址
  host: "http://127.0.0.1"
  #es端口
  port: 9200
  # 用户名，未设置为空
  username:
  # 密码，未设置为空
  password:
```

在config目录配置，因为我们封了方法从那里读取

`conf_es.go`

```go
package config

import "fmt"

type Es struct {
	Host     string `yaml:"host"`     //服务地址
	Port     int    `yaml:"port"`     //端口
	Username string `yaml:"username"` //数据库用户名
	Password string `yaml:"password"` //数据库密码
}

// Es连接配置，
func (es *Es) URL() string {
	return fmt.Sprintf("%s:%d",es.Host,es.Port)
}
```

`Config/enter.go`

```go
package config

type Config struct {
	Mysql    Mysql    `yaml:"mysql"`
	Logger   Logger   `yaml:"logger"`
	System   System   `yaml:"system"`
	SiteInfo SiteInfo `yaml:"site_info"`
	QQ       QQ       `yaml:"qq"`
	Email    Email    `yaml:"email"`
	QiNiu    QiNiu    `yaml:"qiliu"`
	Jwt      Jwt      `yaml:"jwt"`
	Upload   Upload   `yaml:"upload"`
	Redis    Redis    `yaml:"redis"`
	Es       Es       `yaml:"es"`
}
```

**回顾一下**

读取yaml配置文件并加到global.Config，例如

```go
package core

import (
	"fmt"
	"gvb_server/config"
	"gvb_server/global"
	"io/fs"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

/*
go 1.16后废弃ioutil包，各种写法更新

ioutil.ReadAll -> io.ReadAll
ioutil.ReadFile -> os.ReadFile
ioutil.ReadDir -> os.ReadDir
// others
ioutil.NopCloser -> io.NopCloser
ioutil.ReadDir -> os.ReadDir
ioutil.TempDir -> os.MkdirTemp
ioutil.TempFile -> os.CreateTemp
ioutil.WriteFile -> os.WriteFile

*/

//1.指定配置文件路径
//之所以写成全局变量是为了修改配置文件时也能直接使用
const ConfigFile = "settings.yaml"

// InitConf 读取yaml文件的配置
func InitConf() {
	//ps:因为日志的初始化要先读配置文件，所以这个方法内无法使用global.Log

	//关联到我们的配置文件结构体
	c := &config.Config{}

	yamlConf, err := os.ReadFile(ConfigFile)
	if err != nil {
		panic(fmt.Errorf("get yamlConf error: %s", err))
	}
	err = yaml.Unmarshal(yamlConf, c)
	if err != nil {
		log.Fatalf("config Init Unmarshal: %v", err)
	}
	log.Println("config yamlFile load Init success.")

	// fmt.Println(c)
	//全局变量，就是将读取的到配置文件存储为全局变量
	global.Config = c
}
```

加一个Es全局变量,在`global\global.go`

>变量的类型来源自对应源码

```go
package global

import (
	"gvb_server/config"

	"github.com/olivere/elastic/v7"
	"github.com/redis/go-redis/v9"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	// 配置文件全局变量
	Config *config.Config
	//数据库全局变量
	DB     *gorm.DB
	//日志全局变量
	Log *logrus.Logger
	//全局mysql日志
	MysqlLog logger.Interface
	//全局redis
	Redis *redis.Client
	//全局es
	ESClient *elastic.Client
)
```

然后书写连接方法并将实例挂载到全局变量

```go
package core

import (
	"gvb_server/global"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func EsConnect() {
	var err error
    //是否开启集群监听，单机模式需要关闭
	sniffOpt := elastic.SetSniff(false)
	c, err := elastic.NewClient(
		//读取封装好的Es配置
		elastic.SetURL(global.Config.Es.URL()),
		sniffOpt,
		elastic.SetBasicAuth(global.Config.Es.Username, global.Config.Es.Password),
	)
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	//连接成功后将es实例赋值给全局的变量
	global.ESClient = c
}
```

最后在`main.go`入口函数中启用es

```go
package main

import (
	"gvb_server/core"
	_ "gvb_server/docs" // swag init生成后的docs路径
	"gvb_server/flag"
	"gvb_server/global"
	"gvb_server/routers"
)

// @title API文档
// @version 1.0
// @description API文档
// @host 127.0.0.01:9000
// @BasePath /
func main() {
	// 执行读取配置文件的操作
	core.InitConf()
	//查看配置文件全局变量
	// fmt.Println(global.Config)

	//初始化日志
	global.Log = core.InitLogger()
	//测试全局日志
	// global.Log.Warnln("警告")
	// global.Log.Error("错误")
	// global.Log.Info("信息")

	//连接数据库，注册数据库实例
	global.DB = core.InitGorm()
	// fmt.Println(global.DB)


	//初始化redis
	global.Redis = core.ConnectRedis()

	//初始化es
	core.EsConnect()


	//命令行参数绑定
	// go run main.go -db
	//如果在者停止了web服务，后面有关web的就不该执行
	option := flag.Parse()
	if flag.IsWebStop(option){
		flag.SwitchOption(option)
		return
	}

	//注册路由
	router := routers.InitRouter()
	// 根据system配置来设定监听目标
	addr:=global.Config.System.Addr()
	global.Log.Info("gvb_server正在监听:%s",addr)
	err :=router.Run(addr)
	if(err!=nil){
		global.Log.Fatalf(err.Error())
	} 
}
```

## Flag命令创建es表结构

在`flag/es.go`

```go
package flag

import (
	"fmt"
	"gvb_server/models"
)

func EsCreateIndex() {
	err := models.ArticleModel{}.CreateIndex()
	if err!=nil{
		fmt.Println("创建es索引失败")
	}
}
```

在`flag\enter.go`对命令进行分发

```go
package flag

import (
	sys_flag "flag"

	"github.com/fatih/structs"
)

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
  /*
    -es create 创建索引
    -es delete 删除索引
  */
  Es string
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  es := sys_flag.String("es","","es操作")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
    Es:*es,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //在这里解析值，例如 -es create
  //实际上键是es 值是es后面跟的内容
  if option.Es == "create"{
    EsCreateIndex()
      return
  }
    
  //前面的return不要忘记
  //不符合预期走这里
  sys_flag.Usage()
}
```

**命令执行**

```sh
go run main.go -es create
```



# 文章管理



**关于文章管理的一些解读**

```sh
文章管理这一块，传统的做法可以采取MySql查询的方式，例如将文章内容存在一个或多个字段，然后做模糊查询，但是效率极低。

所以这次采用ES，未来好做全文搜索。
```

## 建立表结构

`article_model.go`

文章表结构

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

`comment_model.go`

评论的表结构

```go
package models

// CommentModel 评论表
type CommentModel struct {
	MODEL              `json:",select(c)"`
    //子评论列表
	SubComments        []CommentModel `gorm:"foreignkey:ParentCommentID" json:"sub_comments,select(c)"`
    // 父级评论
	ParentCommentModel *CommentModel  `gorm:"foreignkey:ParentCommentID" json:"comment_model"` 
    // 父评论id
	ParentCommentID    *uint          `json:"parent_comment_id,select(c)"`
    // 评论内容
	Content            string         `gorm:"size:256" json:"content,select(c)"`
    // 点赞数
	DiggCount          int            `gorm:"size:8;default:0;" json:"digg_count,select(c)"` 
    // 子评论数
	CommentCount       int            `gorm:"size:8;default:0;" json:"comment_count,select(c)"` 
    // 文章id
	ArticleID          string         `gorm:"size:32" json:"article_id,select(c)"`
    // 关联的用户
	User               UserModel      `json:"user,select(c)"`
    // 评论的用户
	UserID             uint           `json:"user_id,select(c)"`                                        
}
```

## 文章表Model的ES相关设置

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}

//建立ES索引
func (ArticleModel) Index() string {
	return "article_index"
}

//对应mapping，要与model形成映射
func (ArticleModel) Mapping() string {
  return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  }, 
  "mappings": {
    "properties": {
      "title": { 
        "type": "text"
      },
      "keyword": { 
        "type": "keyword"
      },
      "abstract": { 
        "type": "text"
      },
      "content": { 
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "digg_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": { 
        "type": "text"
      },
      "user_avatar": { 
        "type": "text"
      },
      "category": { 
        "type": "text"
      },
      "source": { 
        "type": "text"
      },
      "link": { 
        "type": "text"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": { 
        "type": "text"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}

// IndexExists 索引是否存在
func (a ArticleModel) IndexExists() bool {
  exists, err := global.ESClient.
    IndexExists(a.Index()).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return exists
  }
  return exists
}

// CreateIndex 创建索引
func (a ArticleModel) CreateIndex() error {
  if a.IndexExists() {
    // 有索引
    a.RemoveIndex()
  }
  // 没有索引
  // 创建索引
  createIndex, err := global.ESClient.
    CreateIndex(a.Index()).
    BodyString(a.Mapping()).
    Do(context.Background())
  if err != nil {
    logrus.Error("创建索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !createIndex.Acknowledged {
    logrus.Error("创建失败")
    return err
  }
  logrus.Infof("索引 %s 创建成功", a.Index())
  return nil
}

// RemoveIndex 删除索引
func (a ArticleModel) RemoveIndex() error {
  logrus.Info("索引存在，删除索引")
  // 删除索引
  indexDelete, err := global.ESClient.DeleteIndex(a.Index()).Do(context.Background())
  if err != nil {
    logrus.Error("删除索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !indexDelete.Acknowledged {
    logrus.Error("删除索引失败")
    return err
  }
  logrus.Info("索引删除成功")
  return nil
}

// Create 添加的方法
func (a ArticleModel) Create() (err error) {
  indexResponse, err := global.ESClient.Index().
    Index(a.Index()).
    BodyJson(a).Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return err
  }
  a.ID = indexResponse.Id
  return nil
}

// ISExistData 是否存在该文章
func (a ArticleModel) ISExistData() bool {
  res, err := global.ESClient.
    Search(a.Index()).
    Query(elastic.NewTermQuery("keyword", a.Title)).
    Size(1).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return false
  }
  if res.Hits.TotalHits.Value > 0 {
    return true
  }
  return false
}
```

