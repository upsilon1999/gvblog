## ES参考文档

```sh
#go-es
https://www.tizi365.com/archives/850.html
#es
https://www.tizi365.com/archives/590.html
```



# ES在本项目中应用

yaml配置文件，`settings.yaml`

```yaml
es:
  #es服务地址
  host: "http://127.0.0.1"
  #es端口
  port: 9200
  # 用户名，未设置为空
  username:
  # 密码，未设置为空
  password:
```

在config目录配置，因为我们封了方法从那里读取

`conf_es.go`

```go
package config

import "fmt"

type Es struct {
	Host     string `yaml:"host"`     //服务地址
	Port     int    `yaml:"port"`     //端口
	Username string `yaml:"username"` //数据库用户名
	Password string `yaml:"password"` //数据库密码
}

// Es连接配置，
func (es *Es) URL() string {
	return fmt.Sprintf("%s:%d",es.Host,es.Port)
}
```

`Config/enter.go`

```go
package config

type Config struct {
	Mysql    Mysql    `yaml:"mysql"`
	Logger   Logger   `yaml:"logger"`
	System   System   `yaml:"system"`
	SiteInfo SiteInfo `yaml:"site_info"`
	QQ       QQ       `yaml:"qq"`
	Email    Email    `yaml:"email"`
	QiNiu    QiNiu    `yaml:"qiliu"`
	Jwt      Jwt      `yaml:"jwt"`
	Upload   Upload   `yaml:"upload"`
	Redis    Redis    `yaml:"redis"`
	Es       Es       `yaml:"es"`
}
```

**回顾一下**

读取yaml配置文件并加到global.Config，例如

```go
package core

import (
	"fmt"
	"gvb_server/config"
	"gvb_server/global"
	"io/fs"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

/*
go 1.16后废弃ioutil包，各种写法更新

ioutil.ReadAll -> io.ReadAll
ioutil.ReadFile -> os.ReadFile
ioutil.ReadDir -> os.ReadDir
// others
ioutil.NopCloser -> io.NopCloser
ioutil.ReadDir -> os.ReadDir
ioutil.TempDir -> os.MkdirTemp
ioutil.TempFile -> os.CreateTemp
ioutil.WriteFile -> os.WriteFile

*/

//1.指定配置文件路径
//之所以写成全局变量是为了修改配置文件时也能直接使用
const ConfigFile = "settings.yaml"

// InitConf 读取yaml文件的配置
func InitConf() {
	//ps:因为日志的初始化要先读配置文件，所以这个方法内无法使用global.Log

	//关联到我们的配置文件结构体
	c := &config.Config{}

	yamlConf, err := os.ReadFile(ConfigFile)
	if err != nil {
		panic(fmt.Errorf("get yamlConf error: %s", err))
	}
	err = yaml.Unmarshal(yamlConf, c)
	if err != nil {
		log.Fatalf("config Init Unmarshal: %v", err)
	}
	log.Println("config yamlFile load Init success.")

	// fmt.Println(c)
	//全局变量，就是将读取的到配置文件存储为全局变量
	global.Config = c
}
```

加一个Es全局变量,在`global\global.go`

>变量的类型来源自对应源码

```go
package global

import (
	"gvb_server/config"

	"github.com/olivere/elastic/v7"
	"github.com/redis/go-redis/v9"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	// 配置文件全局变量
	Config *config.Config
	//数据库全局变量
	DB     *gorm.DB
	//日志全局变量
	Log *logrus.Logger
	//全局mysql日志
	MysqlLog logger.Interface
	//全局redis
	Redis *redis.Client
	//全局es
	ESClient *elastic.Client
)
```

然后书写连接方法并将实例挂载到全局变量

```go
package core

import (
	"gvb_server/global"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func EsConnect() {
	var err error
    //是否开启集群监听，单机模式需要关闭
	sniffOpt := elastic.SetSniff(false)
	c, err := elastic.NewClient(
		//读取封装好的Es配置
		elastic.SetURL(global.Config.Es.URL()),
		sniffOpt,
		elastic.SetBasicAuth(global.Config.Es.Username, global.Config.Es.Password),
	)
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	//连接成功后将es实例赋值给全局的变量
	global.ESClient = c
}
```

最后在`main.go`入口函数中启用es

```go
package main

import (
	"gvb_server/core"
	_ "gvb_server/docs" // swag init生成后的docs路径
	"gvb_server/flag"
	"gvb_server/global"
	"gvb_server/routers"
)

// @title API文档
// @version 1.0
// @description API文档
// @host 127.0.0.01:9000
// @BasePath /
func main() {
	// 执行读取配置文件的操作
	core.InitConf()
	//查看配置文件全局变量
	// fmt.Println(global.Config)

	//初始化日志
	global.Log = core.InitLogger()
	//测试全局日志
	// global.Log.Warnln("警告")
	// global.Log.Error("错误")
	// global.Log.Info("信息")

	//连接数据库，注册数据库实例
	global.DB = core.InitGorm()
	// fmt.Println(global.DB)


	//初始化redis
	global.Redis = core.ConnectRedis()

	//初始化es
	core.EsConnect()


	//命令行参数绑定
	// go run main.go -db
	//如果在者停止了web服务，后面有关web的就不该执行
	option := flag.Parse()
	if flag.IsWebStop(option){
		flag.SwitchOption(option)
		return
	}

	//注册路由
	router := routers.InitRouter()
	// 根据system配置来设定监听目标
	addr:=global.Config.System.Addr()
	global.Log.Info("gvb_server正在监听:%s",addr)
	err :=router.Run(addr)
	if(err!=nil){
		global.Log.Fatalf(err.Error())
	} 
}
```

## Flag命令创建es表结构

在`flag/es.go`

```go
package flag

import (
	"fmt"
	"gvb_server/models"
)

func EsCreateIndex() {
	err := models.ArticleModel{}.CreateIndex()
	if err!=nil{
		fmt.Println("创建es索引失败")
	}
}
```

在`flag\enter.go`对命令进行分发

```go
package flag

import (
	sys_flag "flag"

	"github.com/fatih/structs"
)

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string 
  /*
    -es create 创建索引
    -es delete 删除索引
  */
  Es string
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  es := sys_flag.String("es","","es操作")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
    Es:*es,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //在这里解析值，例如 -es create
  //实际上键是es 值是es后面跟的内容
  if option.Es == "create"{
    EsCreateIndex()
      return
  }
    
  //前面的return不要忘记
  //不符合预期走这里
  sys_flag.Usage()
}
```

**命令执行**

```sh
go run main.go -es create
```



# 文章管理



**关于文章管理的一些解读**

```sh
文章管理这一块，传统的做法可以采取MySql查询的方式，例如将文章内容存在一个或多个字段，然后做模糊查询，但是效率极低。

所以这次采用ES，未来好做全文搜索。
```

## 建立表结构

`article_model.go`

文章表结构

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

`comment_model.go`

评论的表结构

```go
package models

// CommentModel 评论表
type CommentModel struct {
	MODEL              `json:",select(c)"`
    //子评论列表
	SubComments        []CommentModel `gorm:"foreignkey:ParentCommentID" json:"sub_comments,select(c)"`
    // 父级评论
	ParentCommentModel *CommentModel  `gorm:"foreignkey:ParentCommentID" json:"comment_model"` 
    // 父评论id
	ParentCommentID    *uint          `json:"parent_comment_id,select(c)"`
    // 评论内容
	Content            string         `gorm:"size:256" json:"content,select(c)"`
    // 点赞数
	DiggCount          int            `gorm:"size:8;default:0;" json:"digg_count,select(c)"` 
    // 子评论数
	CommentCount       int            `gorm:"size:8;default:0;" json:"comment_count,select(c)"` 
    // 文章id
	ArticleID          string         `gorm:"size:32" json:"article_id,select(c)"`
    // 关联的用户
	User               UserModel      `json:"user,select(c)"`
    // 评论的用户
	UserID             uint           `json:"user_id,select(c)"`                                        
}
```

## 文章表Model的ES相关设置

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}

//建立ES索引
func (ArticleModel) Index() string {
	return "article_index"
}

//对应mapping，要与model形成映射
func (ArticleModel) Mapping() string {
  return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  }, 
  "mappings": {
    "properties": {
      "title": { 
        "type": "text"
      },
      "keyword": { 
        "type": "keyword"
      },
      "abstract": { 
        "type": "text"
      },
      "content": { 
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "digg_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": { 
        "type": "text"
      },
      "user_avatar": { 
        "type": "text"
      },
      "category": { 
        "type": "text"
      },
      "source": { 
        "type": "text"
      },
      "link": { 
        "type": "text"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": { 
        "type": "text"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}

// IndexExists 索引是否存在
func (a ArticleModel) IndexExists() bool {
  exists, err := global.ESClient.
    IndexExists(a.Index()).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return exists
  }
  return exists
}

// CreateIndex 创建索引
func (a ArticleModel) CreateIndex() error {
  if a.IndexExists() {
    // 有索引
    a.RemoveIndex()
  }
  // 没有索引
  // 创建索引
  createIndex, err := global.ESClient.
    CreateIndex(a.Index()).
    BodyString(a.Mapping()).
    Do(context.Background())
  if err != nil {
    logrus.Error("创建索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !createIndex.Acknowledged {
    logrus.Error("创建失败")
    return err
  }
  logrus.Infof("索引 %s 创建成功", a.Index())
  return nil
}

// RemoveIndex 删除索引
func (a ArticleModel) RemoveIndex() error {
  logrus.Info("索引存在，删除索引")
  // 删除索引
  indexDelete, err := global.ESClient.DeleteIndex(a.Index()).Do(context.Background())
  if err != nil {
    logrus.Error("删除索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !indexDelete.Acknowledged {
    logrus.Error("删除索引失败")
    return err
  }
  logrus.Info("索引删除成功")
  return nil
}

// Create 添加的方法
func (a ArticleModel) Create() (err error) {
  indexResponse, err := global.ESClient.Index().
    Index(a.Index()).
    BodyJson(a).Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return err
  }
  a.ID = indexResponse.Id
  return nil
}

// ISExistData 是否存在该文章
func (a ArticleModel) ISExistData() bool {
  res, err := global.ESClient.
    Search(a.Index()).
    Query(elastic.NewTermQuery("keyword", a.Title)).
    Size(1).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return false
  }
  if res.Hits.TotalHits.Value > 0 {
    return true
  }
  return false
}
```

## 添加文章

需要前端传递的数据

```go
type ArticleRequest struct {
	Title    string      `json:"title" binding:"required" msg:"文章标题必填"`   // 文章标题
	Abstract string      `json:"abstract"`                                // 文章简介
	Content  string      `json:"content" binding:"required" msg:"文章内容必填"` // 文章内容
	Category string      `json:"category"`                                // 文章分类
	Source   string      `json:"source"`                                  // 文章来源
	Link     string      `json:"link"`                                    // 原文链接
	BannerID uint        `json:"bannerId"`                               // 文章封面id
	Tags     ctype.Array `json:"tags"`                                    // 文章标签
}
```

文章封面如果没传就随机在选

### **1.从token拿取用户数据**

```go
package article_api

import (
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
}
```

### 2.content处理

1.对文章内容的校验，例如

```sh
防范xss攻击
```

2.文章简介的逻辑

如果文章简介没传，就默认选文章内容的前30个字符

这里要考虑到中文字符截取和其他字符不同，

>推荐搜索:golang字符串的截取

```go
func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName

	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(cr.Content)
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	}
}
```

3.查询banner信息

逻辑:查询banner，

待优化:如果没有bannerId就随机从后台选一张

```go

// 查banner_id下的banner_url
var bannerUrl string

err = global.DB.Model(models.BannerModel{})
	.Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error

if err != nil {
    res.FailWithMessage("banner不存在", c)
    return
}
```

### 3.获取用户头像

```go
 // 查用户头像
  var avatar string
  err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
  if err != nil {
    res.FailWithMessage("用户不存在", c)
    return
  }
```

### 4.发布文章

我们在model上挂载创建文章的方法

```go
// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(a).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

然后调用该方法发布文章

```go
//获取当前时间并格式化
now := time.Now().Format("2006-01-02 15:04:05")
//实例化
article := models.ArticleModel{
    CreatedAt:    now,
    UpdatedAt:    now,
    Title:        cr.Title,
    Abstract:     cr.Abstract,
    Content:      cr.Content,
    UserID:       userID,
    UserNickName: userNickName,
    UserAvatar:   avatar,
    Category:     cr.Category,
    Source:       cr.Source,
    Link:         cr.Link,
    BannerID:     cr.BannerID,
    BannerUrl:    bannerUrl,
    Tags:         cr.Tags,
 }

err = article.Create()
if err != nil {
	global.Log.Error(err)
	res.FailWithMessage(err.Error(), c)
	return
}
res.OkWithMessage("文章发布成功", c)
```

### 5.简易的发布文章接口

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"time"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName

	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(cr.Content)
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	}


	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

### markDown与html互转

#### markDown转Html

在我们接收到content的时候极有可能是markdown格式的，我们先需要转成html格式，

###### 测试demo

```go
package testdata

import (
	"fmt"
	"testing"

	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown转html

func TestMdToHtml(t *testing.T){
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))
}
```

这里使用到的库是

```sh
github.com/russross/blackfriday
```

基本用法是

```go
html := blackfriday.MarkdownCommon([]byte(前端传递来的md片段))
```

##### html获取文本内容

我们从md转出的html还不能使用，需要进一步转成文本格式，此时要用到一个新的库

```go
github.com/PuerkitoBio/goquery
```

测试demo书写如下

```go
package testdata

import (
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown转html

func TestMdToHtml(t *testing.T){
	//将md转html
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))

	//将html转为可读文本格式
	doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	fmt.Println(doc.Text())
}
```

##### xxs过滤

这一步很简单，只需要我们在html转可读文本时过滤掉script标签即可，例如

```go
doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
//移除script标签，过滤xxs
doc.Find("script").Remove()
fmt.Println(doc.Text())
```

我们还可以去获取节点

```go
//返回值是一个列表，如果没有就是[]
//如果有值就是[标识符1,标识符2,...]
nodes := doc.Find("h1").Nodes
```

#### html转md

我们使用的第三方库

```go
github.com/JohannesKaufmann/html-to-markdown
```

#### **完整测试代码**

```go
package htmlandmdtest

import (
	"fmt"
	"strings"
	"testing"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown与html互转

func TestMdToHtml(t *testing.T){
	//将md转html
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))

	//将html转为可读文本格式
	doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	//移除script标签，过滤xxs
	doc.Find("script").Remove()
	fmt.Println(doc.Text())


	//html转md
	converter := md.NewConverter("", true, nil)
	html, _ := doc.Html()
	markdown, err := converter.ConvertString(html)
	fmt.Println(markdown, err)
}
```

### 添加文章优化

#### 1.content处理

刚才的content我们直接存入了es，那是很不合理的，

```sh
要进行xxs过滤:
1.把前端传递来的markdown形式content转成html
2.进行xxs过滤后再转回markdown，方便前端回显
```

```go
 // 处理content，把markdown转为html
  unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
  doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
  //fmt.Println(doc.Text())
 // 是不是有script标签
  nodes := doc.Find("script").Nodes
  //如果有script标签就过滤掉然后再将过滤后结果转回markdown
  if len(nodes) > 0 {
    // 有script标签
    doc.Find("script").Remove()
    converter := md.NewConverter("", true, nil)
    html, _ := doc.Html()
    markdown, _ := converter.ConvertString(html)
    cr.Content = markdown
  }
```

**理解**

```sh
content始终是前端传递的markdown，如果有xxs，我们就过滤后再转回markdown
```

#### 2.简介的处理

按照我们截取简介的逻辑，就会把markdown符号写入简介，所以应该要做处理

```sh
我们不是直接对content进行截取，而是应该截取content转成的html可读文本，所以应该对`doc.Text()`进行截取
```

```go
if cr.Abstract == "" {
    // 汉字的截取不一样
    abs := []rune(doc.Text())
    // 将content转为html，并且过滤xss，以及获取中文内容
    if len(abs) > 100 {
      cr.Abstract = string(abs[:100])
    } else {
      cr.Abstract = string(abs)
    }
  }
```

#### 3.banner的优化

如果没有bannerId就随机从后台选一张，

```sh
go语言中有两个包提供了rand，分别为 "math/rand" 和 "crypto/rand", 对应两种应用场景。
一、"math/rand" 包实现了伪随机数生成器。也就是生成 整形和浮点型
二、”crypto/rand“ 包实现了用于加解密的更安全的随机数生成器。
```

具体的我们单独开文档讲解，这里使用`math/rand`

```go
// 不传banner_id,后台就随机去选择一张
  if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
      res.FailWithMessage("没有banner数据", c)
      return
    }
    rand.Seed(time.Now().UnixNano())
    cr.BannerID = bannerIDList[rand.Intn(len(bannerIDList))]
  }
```

注意从go 1.20开始，`math/rand`包已经升级到`math/rand/v2`，

```sh
1.删除 Rand.Read 和顶层的 Read。
2.移除 Source.Seed、Rand.Seed 和顶层 Seed。（意味着像 Int 这样的顶层函数将总是随机播种）
3.移除 Source64，现在 Source 提供了 Uint64 方法，原有的方法没有必要存在了。
4.在 Float32 和 Float64 中使用更直接的实现。以 Float64 为例，它最初使用 float64(r.Int63()) / (1<<63)。但这有一个问题，就是偶尔会四舍五入到 1.0，而 Float64 一定不会。我们期望改成 float64(r.Int63n(1<<53)) / (1<<53)，这就避免了四舍五入的问题。

5.用 Rand.Shuffle 的方式实现 Rand.Perm。Shuffle 的效率更高一些，这样可以确保只有一个实现。
6.将 Int31、Int31n、Int63、Int64n 更名为 Int32、Int32n、Int64、Int64n。这些名字是不必要的迂腐和混乱。
7.添加 Uint32, Uint32n, Uint64, Uint64n, Uint, Uintn，将会是 Rand 上的顶级函数和方法。
8.在 Intn, Uintn, Int32n, Uint32n, Int64n, Uint64n 中使用 Lemire 的算法。性能会有新的突破。
9.添加一个新的 Source 实现，PCG-DXSM。包含：NewPCG 等相关 API 可以调用。
10.删除 Mitchell & Reeds LFSR 生成器和 NewSource。
```

所以新的写法

```go
//获得一个rand.Rand源
r:=rand.New(rand.NewSource(time.Now().UnixNano()))
//生成[0,10)之间的int数
r.Intn(10)
```

所以我们的随机取banner可以改为

```go
// 不传banner_id,后台就随机去选择一张
if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
        res.FailWithMessage("没有banner数据", c)
        return
    }

    //go 1.22设立随机源
    //然后调用随机源上的方法
    r:=rand.New(rand.NewSource(time.Now().UnixNano()))
    cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
}
```

##### 关于随机数

```go
package rand_test

import (
	"fmt"
	"testing"
	"time"

	"math/rand"
)

func TestRandom(t *testing.T) {
	//go 1.22设立随机源
	//设立随机种子，这里采用秒级时间戳
	src := rand.NewSource(time.Now().UnixNano())
	fmt.Println(time.Now().UnixNano())
	//注册种子生成实例
    r := rand.New(src)
	//获取[0,100]的随机整数
    number := r.Intn(100)
    fmt.Println(number)
}
```

**为什么要设立随机种子**

因为只有种子不同我们才能得到不一样的随机数，否则将获得恒定值

```go
//只有rand实例的种子值不同，才可能获得不同的随机数
number := r.Intn(100)
```

**如何设立随机种子**

我们采用时间戳来作为种子，时间戳随着时间变化，每秒都不同，能满足我们的需求

```go
//设立随机种子，这里采用秒级时间戳
//这一步是生成source类型的值，因为New实例只接收该类型
src := rand.NewSource(time.Now().UnixNano())
//注册种子生成实例
r := rand.New(src)
```

##### **测试缓存的问题**

我们在测试的时候发现时间戳不会产生变化，例如

```go
func TestRandom(t *testing.T) {
	//打印时间戳一直不变
	fmt.Println(time.Now().UnixNano())
}
```

观察输出结果

```go
=== RUN   TestRandom
1721627055350958600
--- PASS: TestRandom (0.00s)
PASS
ok      gvb_server/testdata/rand_test   (cached)
```

这是因为除了第一次的输出结果，后续都采用了`cached`，也就是走了缓存，所以我们不能直接

```sh
go test
```

要不走缓存，我们需要加入`-count=1`,

```sh
# 执行这个目录下的所有测试方法
go test -v -count=1 
```

如果只想运行其中的一个用例，例如 `TestRandom`，可以用 `-run` 参数指定，该参数支持通配符 `*`，和部分正则表达式，例如 `^`、`$`

```sh
go test -v -count=1 -run TestRandom
```

**解决方案汇总**

当`go test`以包列表模式运行时，`go test`会缓存成功的包的测试结果以避免不必要的重复测试。当然，有时候我们测试的时候并不喜欢有缓存，我们可以手动禁用缓存。可以通过下列方式禁用缓存：

- 带上-count=1参数禁用缓存。

  如，执行下面命令测试，便会禁用缓存测试结果

```go
go test -v -count=1 filename_test.go
```

- 手动清除测试缓存

除了在执行测试命令的时候加上禁用缓存参数，我们还可以执行下面的命令手动清除缓存，需要注 意的是，每次都得清除，不然下次执行的还是上次的结果。

```go
go clean -testcache
```

- 环境变量设置法

除了上面两种方式，还可以通过环境变量来改变。我们只需要设置GOCACHE=off即可禁用缓存，不过这样执行测试命令的时候会明显感觉有点慢，这很正常，肯定没有直接用缓存的结果快。但我对比了第一种方式，发现加行-count=1 参数这种方式比设置环境变量这种效率要高，速度要快点。

所以，在用golang测试，千万不要只仅仅用go test就完了，必要时还得加上需要的参数，有些或许连-v参数都不会加，事实上这样是不会打印出log日志的。加上-count就更完美了。

```go
go test -v -count=1 filename_test.go
```

在VsCode中要起效，也是需要在设置中加上此参数的。如下：

```bash
 "go.testFlags": ["-v","-count=1"]
```

##### 关于零值问题

我们判断没有传bannerId时使用了

```go
if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
        res.FailWithMessage("没有banner数据", c)
        return
    }

    //go 1.22设立随机源
    //然后调用随机源上的方法
    r:=rand.New(rand.NewSource(time.Now().UnixNano()))
    cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
}
```

之所以`cr.BannerId == 0`，是因为bannerId是整形，其零值为0，但我们没有传递时将默认采用零值，所以在数据设计时要排除零值数据。

#### 4.es索引优化

我们在执行es入库操作的时候有几个关键点必不可少。

```sh
1.插入es数据前必须确定文章标题存在，因为我们要通过文章标题来判断两篇文章是否一样(机器和人不一样，当然我们也能通过重复度来判断是否一样，但是那样过于复杂，且我们没有查重的需求)
2.得有一个keyword字段，其类型也是keyword
```

**model的修改**

加入了keyword关键字字段,这个字段存的实际上就是title，原因

```sh
我们在es中的title是text类型，只能模糊匹配，所以需要一个单独的字段存title，然后设立精确判断类型，好用于做唯一性判断

注:这本质上不是es的问题，而是我们采用的第三方库的问题
```

代码修改

```go
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword",omit(list) structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

**2.es对应map修改**

需要精确匹配的都需要使用keyword类型

```go
func (ArticleModel) Mapping() string {
	return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  }, 
  "mappings": {
    "properties": {
      "title": { 
        "type": "text"
      },
      "keyword": { 
        "type": "keyword"
      },
      "abstract": { 
        "type": "text"
      },
      "content": { 
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "digg_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": { 
        "type": "keyword"
      },
      "user_avatar": { 
        "type": "keyword"
      },
      "category": { 
        "type": "keyword"
      },
      "source": { 
        "type": "keyword"
      },
      "link": { 
        "type": "keyword"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": { 
        "type": "keyword"
      },
      "tags": { 
        "type": "keyword"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}
```

**3.封装判断唯一性的方法**

通过精确匹配keyword来判断文章是否存在

```go
// ISExistData 是否存在该文章
func (a ArticleModel) ISExistData() bool {
	//NewTermQuery(key,value) 精确匹配键值
	res, err := global.ESClient.
		Search(a.Index()).
		Query(elastic.NewTermQuery("keyword", a.Title)).
		Size(1).
		Do(context.Background())
    //这里报错，虽然是操作es出错了，但我们也认为是没存在文章
	//错误根据错误捕捉来人工修改
	if err != nil {
		logrus.Error(err.Error())
		return false
	}
    //查询结果
	if res.Hits.TotalHits.Value > 0 {
		return true
	}
	return false
}
```

>心得:写方法时搞清楚方法的具体需求，我们只要根据需求实现对应内容即可，至于很多额外的错误，通过抛出错误来后期定位，例如这里的es报错，我们的目的是判断文章是否存在，即使报错也应该认为不存在，然后通过抛出错误来定位修复即可

**4.添加文章接口的使用**

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
	
	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}
	
	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

#### 添加文章优化后的代码

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
	
	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

后续的优化空间，可以借助service层将复杂逻辑抽离。

## 文章列表

一共有两个地方需要请求文章列表接口，

```sh
后台的文章列表管理界面
前端的文章列表展示界面
```

共同点

```sh
不需要展示文章内容，因为前端文章列表展示界面只要简介就可以，所以不需要把复杂的内容展示出来
```

### 简易的获取文章列表

我们先封装一个service，从es中分页获取数据，例如

`service/es_ser/enter.go`

```go
package es_ser

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func CommList(key string, page int, limit int)(list []models.ArticleModel,count int,err error){
	boolSearch := elastic.NewBoolQuery()
	from := page
	if key != "" {
	  boolSearch.Must(
		//查询title值为key的数据，由于我们的title设置为text类型，所以支持模糊查询
		elastic.NewMatchQuery("title", key),
	  )
	}
	if limit == 0 {
	  limit = 10
	}
	if from == 0 {
	  from = 1
	}

	res, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Query(boolSearch).
    From((from - 1) * limit).
    Size(limit).
    Do(context.Background())

	if err != nil {
		logrus.Error(err.Error())
		return nil,0,err
	}

	count = int(res.Hits.TotalHits.Value) //搜索到结果总条数
	demoList := []models.ArticleModel{}
	for _,hit := range res.Hits.Hits{
		var model models.ArticleModel
		data,err := hit.Source.MarshalJSON()
		if err!=nil{
			logrus.Error(err.Error())
			continue
		}

		err = json.Unmarshal(data,&model)
		if err!=nil{
			logrus.Error(err)
		}
		model.ID = hit.Id 
		demoList = append(demoList, model)
	}
	fmt.Println(demoList,count)
	return demoList,count,err
}
```

在获取文章列表的接口进行使用

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleListView(c *gin.Context) {
	var cr models.PageInfo
	err := c.ShouldBindQuery(&cr)
	if err != nil {
	  res.FailWithCode(res.ArgumentError, c)
	  return
	}
	list,count,err := es_ser.CommList(cr.Key,cr.Page,cr.Limit)
	if err != nil{
		global.Log.Error(err)
		res.FailWithMessage("查询失败",c)
	}
	res.OkWithList(list,int64(count),c)
}
```

### 移除文章内容字段

#### es方案

在es的列表查询中过滤掉content，这种方式最简单，但是会导致方法复用性低

```go
//注意这里面的FetchSourceContext,我们在里面写了过滤文章内容字段的逻辑
res, err := global.ESClient.
Search(models.ArticleModel{}.Index()).
Query(boolSearch).
FetchSourceContext(elastic.NewFetchSourceContext(true).Exclude("content")).
From((from - 1) * limit).
Size(limit).
Do(context.Background())
```

完整代码

```go
package es_ser

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func CommList(key string, page int, limit int)(list []models.ArticleModel,count int,err error){
	boolSearch := elastic.NewBoolQuery()
	from := page
	if key != "" {
	  boolSearch.Must(
		//查询title值为key的数据，由于我们的title设置为text类型，所以支持模糊查询
		elastic.NewMatchQuery("title", key),
	  )
	}
	if limit == 0 {
	  limit = 10
	}
	if from == 0 {
	  from = 1
	}
  
	//注意这里面的FetchSourceContext,我们在里面写了过滤文章内容字段的逻辑
	res, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Query(boolSearch).
    FetchSourceContext(elastic.NewFetchSourceContext(true).Exclude("content")).
    From((from - 1) * limit).
    Size(limit).
    Do(context.Background())

	if err != nil {
		logrus.Error(err.Error())
		return nil,0,err
	}

	count = int(res.Hits.TotalHits.Value) //搜索到结果总条数
	demoList := []models.ArticleModel{}
	for _,hit := range res.Hits.Hits{
		var model models.ArticleModel
		data,err := hit.Source.MarshalJSON()
		if err!=nil{
			logrus.Error(err.Error())
			continue
		}

		err = json.Unmarshal(data,&model)
		if err!=nil{
			logrus.Error(err)
		}
		model.ID = hit.Id 
		demoList = append(demoList, model)
	}
	fmt.Println(demoList,count)
	return demoList,count,err
}
```

#### 结构体方案

我们按照之前的写法会再写一个结构体，然后将文章内容字段除外，例如

```go
type ArticleListRequest struct{
    Title    string      `json:"title" binding:"required" msg:"文章标题必填"`   // 文章标题
	Abstract string      `json:"abstract"`                                // 文章简介
	Category string      `json:"category"`                                // 文章分类
	Source   string      `json:"source"`                                  // 文章来源
	Link     string      `json:"link"`                                    // 原文链接
	BannerID uint        `json:"bannerId"`                               // 文章封面id
	Tags     ctype.Array `json:"tags"`                                    // 文章标签
}
```

但是这样写很麻烦，因为每次有不同我们都要重新写结构体

#### **json-filter方案**

一个很好用的json序列化第三方包

```sh
github.com/liu-cn/json-filter/filter
```

可以按不同的场景去过滤要渲染的json字段，可以选择，也可以排查

##### json-filter的使用

```go
package jsonfilter_test

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/liu-cn/json-filter/filter"
)

type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile)"`
	Price      string    `json:"price,select(profile)"`
}
  
func TestJsonFilter(t *testing.T){
	user := User{
		UID:        1,
		Nickname:   "boyan",
		Avatar:     "avatar",
		Sex:        1,
		VipEndTime: time.Now().Add(time.Hour * 24 * 365),
		Price:      "999.9",
	  }
	  marshal, err := json.Marshal(user)
	  if err != nil {
		panic(err)
	  }
    
	  //{"uid":1,"nickname":"boyan","avatar":"avatar","sex":1,"vip_end_time":"2023-03-06T23:11:22.622693+08:00","price":"999.9"}
	  fmt.Println(string(marshal)) 
	
	  //{"avatar":"avatar","nickname":"boyan","uid":1}
	  fmt.Println(filter.Select("article", user)) 
	
	  //{"nickname":"boyan","price":"999.9","sex":1,"vip_end_time":"2023-03-06T23:31:28.636529+08:00"}
	  fmt.Println(filter.Select("profile", user)) 
	  //{"nickname":"boyan"}
	  fmt.Println(filter.Select("list", user))
	  fmt.Println(filter.Omit("vip", user))
}
```

**1.用select对json进行分组**

基本语法

```sh
type 结构体名 struct{
	字段1 字段类型  `json:"对应json字符,select(组1|组2)"`
}
```

示例

```go
type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile)"`
	Price      string    `json:"price,select(profile)"`
}
```

在返回结构体时将返回该组的字段

```go
fmt.Println(filter.Select(组名, 结构体)) 

//只操作该组的json，例如uid、avatar、nickname
fmt.Println(filter.Select("article", user)) 
```

**2.omit排除某个字段**

```go
type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile),omit(vip)"`
	Price      string    `json:"price,select(profile)"`
  }
```

添加排除分组，但我们使用这个组时包含该组名的字段将被排除

```go
//例如vip_end_time将被排除
fmt.Println(filter.Omit("vip", user))
```

更多使用可以去查看`docs`下的json-filter文档

**空值处理**



##### 项目中使用

我们在article_model中过滤掉

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

然后在查询结果中进行使用

```go
func (ArticleApi) ArticleListView(c *gin.Context) {
  var cr models.PageInfo
  if err := c.ShouldBindQuery(&cr); err != nil {
    res.FailWithCode(res.ArgumentError, c)
    return
  }
  list, count, err := es_ser.CommList(cr.Key, cr.Page, cr.Limit)
  if err != nil {
    global.Log.Error(err)
    res.OkWithMessage("查询失败", c)
    return
  }

  //对返回的结构体进行过滤
  res.OkWithList(filter.Omit("list", list), int64(count), c)
}
```

## 文章详情

### 通过es的id查询

需求

```sh
1.根据文章的es的id去查询对应的文章详情,然后在前端网页显示
```

service层获取es详情

```go
//根据id获取es详情
func CommDetail(id string) (model models.ArticleModel, err error) {
    
	res, err := global.ESClient.Get().
	  Index(models.ArticleModel{}.Index()).
	  Id(id).
	  Do(context.Background())
    
	if err != nil {
	  return
	}
	err = json.Unmarshal(res.Source, &model)
	if err != nil {
	  return
	}
	model.ID = res.Id
	return
}
```

获取文章详情的接口

```go
package article_api

import (
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
)

type ESIDRequest struct {
	ID string `json:"id" form:"id" uri:"id"`
}
  
func (ArticleApi) ArticleDetailView(c *gin.Context) {
	var cr ESIDRequest
	err := c.ShouldBindUri(&cr)
	if err != nil {
	  res.FailWithCode(res.ArgumentError, c)
	  return
	}
	model, err := es_ser.CommDetail(cr.ID)
	if err != nil {
	  res.FailWithMessage(err.Error(), c)
	  return
	}
	res.OkWithData(model, c)
  }
```

### 通过文章title来查询

由于我们设立了keyword来存储文章title，且该字段精确匹配，所以我们可以实现通过文章标题来获取数据

**封装service方法**

```go
package es_ser

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

//根据keyword，即文章标题获取文章详情
func CommDetailByKeyword(key string) (model models.ArticleModel, err error) {
	res, err := global.ESClient.Search().
	  Index(models.ArticleModel{}.Index()).
	  Query(elastic.NewTermQuery("keyword", key)).
	  Size(1).
	  Do(context.Background())
	if err != nil {
	  return
	}
	if res.Hits.TotalHits.Value == 0 {
	  return model, errors.New("文章不存在")
	}
	hit := res.Hits.Hits[0]
  
	err = json.Unmarshal(hit.Source, &model)
	if err != nil {
	  return
	}
	model.ID = hit.Id
	return
}
```

## 文章日历

### 文章时间聚合搜索

这里的核心是es的时间聚合，我们这里按照天去聚合

```sh
什么是聚合
实际上就和mysql中的group by等的功能类似，就是做分组
```

#### 根据小时分组的demo

这里贴一下es查询的源码

```json
POST /sales/_search?size=0
{
    "aggs" : {
        // 聚合查询名字，随便取一个
        "sales_over_time" : { 
            // 聚合类型为: date_histogram
            "date_histogram" : { 
                // 根据date字段分组
                "field" : "date",
                // 分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年）
                "calendar_interval" : "month", 
                "format" : "yyyy-MM-dd" // 设置返回结果中桶key的时间格式
            }
        }
    }
}
```

贴一张结果

```go
{
"took": 2,
"timed_out": false,
"_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
},
"hits": {
    "total": {
        "value": 3,
        "relation": "eq"
    },
    "max_score": null,
    "hits": [ ]
},
"aggregations": {
    "my_name": {
        "buckets": [
            {
                "key_as_string": "2024-07-23 15:21:00",
                "key": 1721748060000,
                "doc_count": 1
            },
            {
                "key_as_string": "2024-07-23 15:22:00",
                "key": 1721748120000,
                "doc_count": 2
            }
        	]
        }
    }
}
```

go的测试代码

```go
package elasticSearch_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)
type BucketsType struct {
	Buckets []struct {
	  KeyAsString string `json:"key_as_string"`
	  Key         int64  `json:"key"`
	  DocCount    int    `json:"doc_count"`
	} `json:"buckets"`
}
func TestDateAgg(t *testing.T) {
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()
	// 创DateHistogram桶聚合
	aggs := elastic.NewDateHistogramAggregation().
	Field("created_at"). // 根据date字段值，对数据进行分组
	//  分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年)
	CalendarInterval("minute").
	// 设置返回结果中桶key的时间格式
	Format("yyyy-MM-dd")

	searchResult, err := client.Search().
	Index("article_index"). // 设置索引名
	Query(elastic.NewMatchAllQuery()). // 设置查询条件
	Aggregation("sales_over_time", aggs). // 设置聚合条件，并为聚合条件设置一个名字
	Size(0). // 设置分页参数 - 每页大小,设置为0代表不返回搜索结果，仅返回聚合分析结果
	Do(ctx) // 执行请求

	if err != nil {
		// Handle error
		panic(err)
	}

	// 使用DateHistogram函数和前面定义的聚合条件名称，查询结果
	agg, found := searchResult.Aggregations.DateHistogram("sales_over_time")
	if !found {
		logrus.Fatal("没有找到聚合数据")
	}
    if len(agg.Buckets)==0{
		logrus.Fatal("没有待展示的数据")
	}
	// 遍历桶数据
	for _, bucket := range agg.Buckets {
		// 每一个桶都有一个key值，其实就是分组的值，可以理解为SQL的group by值
		bucketValue := bucket.Key

		// 打印结果， 默认桶聚合查询，都是统计文档总数
		fmt.Printf("bucket = %v 文档总数 = %d\n", bucketValue, bucket.DocCount)
	}
}
```

上述测试代码是一种方案，另一种是直接从聚类分析结果的Aggregations属性上读取，这个属性是个`map[string]any`,键就是我们使用Aggregation()传入的第一个参数，对应值就是查询结果，不过由于结果是字节切片，需要使用字符串转化，例如

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

func (ArticleApi) ArticleCalendarView(c *gin.Context) {
	// 时间聚合函数
	//field按照哪个字段聚合
	//CalendarInterval按照什么维度聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")

	//Aggregation(键名,聚合函数)
	result, err := global.ESClient.
	Search(models.ArticleModel{}.Index()).
	Query(elastic.NewMatchAllQuery()).
	Aggregation("calendar", agg).
	Size(0).
	Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("查询失败", c)
		return
	}
	//result.Aggregations["calendar"]是一个byte切片
	//要转成string才可读
	fmt.Println(string(result.Aggregations["calendar"]))
}
```

**难点小结**

```sh
实际上方法并不难，问题出在后文问题总结所说，在插入es数据时发生了错误，导致我们正确聚类。
```

### 时间段搜索

指定聚合搜索的时间段，例如从今天到去年今天

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

func (ArticleApi) ArticleCalendarView(c *gin.Context) {

	// 时间聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")
  
	// 时间段搜索
	// 从今天开始，到去年的今天
	now := time.Now()
	//获取一年前的时间
	aYearAgo := now.AddDate(-1, 0, 0)
	fmt.Println("一年前时间",aYearAgo)
  
	format := "2006-01-02 15:04:05"
	// lt 小于  gt 大于
    //时间使用format的原因是因为我们存入的created_at也使用了格式化，为了方便比较，应该格式化为同一格式
	query := elastic.NewRangeQuery("created_at").
	  Gte(aYearAgo.Format(format)).
	  Lte(now.Format(format))
  
	result, err := global.ESClient.
	  Search(models.ArticleModel{}.Index()).
	  Query(query).
	  Aggregation("calendar", agg).
	  Size(0).
	  Do(context.Background())
	if err != nil {
	  global.Log.Error(err)
	  res.FailWithMessage("查询失败", c)
	  return
	}

	fmt.Printf("查询结果为%#v",string(result.Aggregations["calendar"]))
}
```

要返回给前端的格式如下

```json
dateList:[
    {date:"2023-12-14",count:1},
    {date:"2024-05-01",count:5}
]
```

所以构造结构体

```go
//用于构造响应数据
type CalendarResponse struct {
  Date  string `json:"date"`
  Count int    `json:"count"`
}

//用于解析获取es的结果
type BucketsType struct {
  Buckets []struct {
    KeyAsString string `json:"key_as_string"`
    Key         int64  `json:"key"`
    DocCount    int    `json:"doc_count"`
  } `json:"buckets"`
}
```

解析es结果

```go
//构造出一种格式{时间字符串:count}
//这样可以配合时间遍历获得单天的count
var DateCount = map[string]int{}

(...获取查询结果result)

//将获得的结果映射到json中
var data BucketsType
_ = json.Unmarshal(result.Aggregations["calendar"], &data)

var resList = make([]CalendarResponse, 0)
//将获得的结果，例如
/*
	data.Buckets= [
            {
                "key_as_string": "2024-07-23 15:21:00",
                "key": 1721748060000,
                "doc_count": 1
            },
            {
                "key_as_string": "2024-07-23 15:22:00",
                "key": 1721748120000,
                "doc_count": 2
            }
        	]
     }
*/
for _, bucket := range data.Buckets {
    //按照我们之前的format格式化时间
    Time, _ := time.Parse(format, bucket.KeyAsString)
    //构造 {时间字符串:count}
    DateCount[Time.Format("2006-01-02")] = bucket.DocCount
}
```

现在要构造CalendarResponse数据

```go
//now.Sub(aYearAgo).Hours()获得两个时间差之间的总小时数
//除以24获得天数，由于格式是int64，所以我们转换一下
days := int(now.Sub(aYearAgo).Hours() / 24)
//按照天数遍历
for i := 0; i <= days; i++ {
    //格式化每一天，使用AddDate(0, 0, i)获得递增时间序列
    day := aYearAgo.AddDate(0, 0, i).Format("2006-01-02")

    //由于{时间字符串:count}格式，我们可以通过时间获取数据
    count, _ := DateCount[day]
    resList = append(resList, CalendarResponse{
      Date:  day,
      Count: count,
    })
  }
```

**完整代码**

```go
package article_api

import (
	"context"
	"encoding/json"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

/*
	用于构造前端所需数据
	dateList:[
		{date:"2023-12-14",count:1},
		{date:"2024-05-01",count:5}
	]
*/
type CalendarResponse struct {
	Date  string `json:"date"`
	Count int    `json:"count"`
}
  
//用于解析获取es的结果
type BucketsType struct {
	Buckets []struct {
	  KeyAsString string `json:"key_as_string"`
	  Key         int64  `json:"key"`
	  DocCount    int    `json:"doc_count"`
	} `json:"buckets"`
 }

//构造出一种格式{时间字符串:count}
//这样可以配合时间遍历获得单天的count
var DateCount = map[string]int{}

func (ArticleApi) ArticleCalendarView(c *gin.Context) {

	// 时间聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")
  
	// 时间段搜索
	// 从今天开始，到去年的今天
	now := time.Now()
	//获取一年前的时间
	aYearAgo := now.AddDate(-1, 0, 0)
	// fmt.Println("一年前时间",aYearAgo)
  
	format := "2006-01-02 15:04:05"
	// lt 小于  gt 大于
	//时间使用format的原因是因为我们存入的created_at也使用了格式化，为了方便比较，应该格式化为同一格式
	query := elastic.NewRangeQuery("created_at").
	  Gte(aYearAgo.Format(format)).
	  Lte(now.Format(format))
  
	result, err := global.ESClient.
	  Search(models.ArticleModel{}.Index()).
	  Query(query).
	  Aggregation("calendar", agg).
	  Size(0).
	  Do(context.Background())
	if err != nil {
	  global.Log.Error(err)
	  res.FailWithMessage("查询失败", c)
	  return
	}
	// fmt.Printf("查询结果为%#v",string(result.Aggregations["calendar"]))

	//将获得的结果映射到json中
	var data BucketsType
  	err = json.Unmarshal(result.Aggregations["calendar"], &data)
	if err!=nil{
		global.Log.Error(err)
		res.FailWithMessage("结果解析错误", c)
		return
	}
	//将获得的结果，例如
	/*
		data.Buckets= [
				{
					"key_as_string": "2024-07-23 15:21:00",
					"key": 1721748060000,
					"doc_count": 1
				},
				{
					"key_as_string": "2024-07-23 15:22:00",
					"key": 1721748120000,
					"doc_count": 2
				}
				]
		}
	*/
  	var resList = make([]CalendarResponse, 0)
  	for _, bucket := range data.Buckets {
		//按照我们之前的format格式化时间
		Time, _ := time.Parse(format, bucket.KeyAsString)
		//构造 {时间字符串:count}
		DateCount[Time.Format("2006-01-02")] = bucket.DocCount
  	}

	//now.Sub(aYearAgo).Hours()获得两个时间差之间的总小时数
	//除以24获得天数，由于格式是int64，所以我们转换一下
	days := int(now.Sub(aYearAgo).Hours() / 24)

	//按照天数遍历
	for i := 0; i <= days; i++ {

		//格式化每一天，使用AddDate(0, 0, i)获得递增时间序列
		day := aYearAgo.AddDate(0, 0, i).Format("2006-01-02")

		//由于{时间字符串:count}格式，我们可以通过时间获取数据
		count, _ := DateCount[day]
		resList = append(resList, CalendarResponse{
			Date:  day,
			Count: count,
		})
	}

	res.OkWithData(resList, c)
	
}
```



## 问题总结

### 文章添加的问题

我在做聚合分析的时候，发现`created_at`字段聚合不到数据，`createdAt`提示类型错误，原因

**model层**

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword",omit(list) structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

**mapping**

我们用这个来初始化了索引

```go
func (ArticleModel) Mapping() string {
	return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  }, 
  "mappings": {
    "properties": {
      "title": { 
        "type": "text"
      },
      "keyword": { 
        "type": "keyword"
      },
      "abstract": { 
        "type": "text"
      },
      "content": { 
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "digg_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": { 
        "type": "keyword"
      },
      "user_avatar": { 
        "type": "keyword"
      },
      "category": { 
        "type": "keyword"
      },
      "source": { 
        "type": "keyword"
      },
      "link": { 
        "type": "keyword"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": { 
        "type": "keyword"
      },
      "tags": { 
        "type": "keyword"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}
```

**插入时的操作**

```go
func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
	
	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}

// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(a).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

问题的来源就在`Create`方法这里,

```sh
1.ArticleCreateView方法中调用Create时插入的是json，此时字段映射是驼峰形式的，我们直接使用BodyJson插入时就把驼峰形式插入进去，又由于es遇到不存在的键名会直接给他text类型，所以实际上创建的是updatedAt、bannerId、createdAt等，且都是text类型数据。

2.Mapping初始化索引就相当于建表，但是由于es的易扩展性，所以不具备强制约束和对应关系，这也就是为什么我们插入updatedAt等的时候只会新加字段而不会与update_at进行关联。
```

**报错记录**

```sh
Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [updatedAt] in order to load field data by uninverting the inverted index. Note that this can use significant memory
```

这是我们对`updatedAt`做聚类时报的错，指的是我们不能对text类型做时间聚类，因为updateAt是es自动根据我们插入的内容扩展的，默认类型为text。

**解决方案**

在插入es前，将json用map改造，

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword",omit(list) structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

改造成map再插入

```go
// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	maps := structs.Map(&a)
	fmt.Printf("map值为%#v",maps)
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(maps).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

#### 小结

```sh
1.es和mysql的本质区别，es是文档类型的，实际上不具备表结构，所以非常容易扩展，我们习惯性存入键值对类型，但es遇到陌生键的时候会自动扩展，且赋予text类型。

2.es的键命名，es和mysql不一样，实际上es的键可以是蛇形，也可以是驼峰，我们使用蛇形只是因为使用习惯。
```

### json-filter与structs包冲突

对于如下model

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword",omit(list) structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

我们在做map转化时发现，凡是使用json-filter方法的json映射，在structs映射中首字母都被大写了，例如

```sh
Keyword、Content
```

解决方案，将json映射放到structs映射后面

```go
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `structs:"keyword" json:"keyword",omit(list)` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `structs:"content" json:"content",omit(list)` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	DiggCount     int `json:"diggCount" structs:"digg_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```





