## ES 参考文档

```sh
#go-es
https://www.tizi365.com/archives/850.html
#es
https://www.tizi365.com/archives/590.html
```

# ES 在本项目中应用

yaml 配置文件，`settings.yaml`

```yaml
es:
  #es服务地址
  host: "http://127.0.0.1"
  #es端口
  port: 9200
  # 用户名，未设置为空
  username:
  # 密码，未设置为空
  password:
```

在 config 目录配置，因为我们封了方法从那里读取

`conf_es.go`

```go
package config

import "fmt"

type Es struct {
	Host     string `yaml:"host"`     //服务地址
	Port     int    `yaml:"port"`     //端口
	Username string `yaml:"username"` //数据库用户名
	Password string `yaml:"password"` //数据库密码
}

// Es连接配置，
func (es *Es) URL() string {
	return fmt.Sprintf("%s:%d",es.Host,es.Port)
}
```

`Config/enter.go`

```go
package config

type Config struct {
	Mysql    Mysql    `yaml:"mysql"`
	Logger   Logger   `yaml:"logger"`
	System   System   `yaml:"system"`
	SiteInfo SiteInfo `yaml:"site_info"`
	QQ       QQ       `yaml:"qq"`
	Email    Email    `yaml:"email"`
	QiNiu    QiNiu    `yaml:"qiliu"`
	Jwt      Jwt      `yaml:"jwt"`
	Upload   Upload   `yaml:"upload"`
	Redis    Redis    `yaml:"redis"`
	Es       Es       `yaml:"es"`
}
```

**回顾一下**

读取 yaml 配置文件并加到 global.Config，例如

```go
package core

import (
	"fmt"
	"gvb_server/config"
	"gvb_server/global"
	"io/fs"
	"log"
	"os"

	"gopkg.in/yaml.v3"
)

/*
go 1.16后废弃ioutil包，各种写法更新

ioutil.ReadAll -> io.ReadAll
ioutil.ReadFile -> os.ReadFile
ioutil.ReadDir -> os.ReadDir
// others
ioutil.NopCloser -> io.NopCloser
ioutil.ReadDir -> os.ReadDir
ioutil.TempDir -> os.MkdirTemp
ioutil.TempFile -> os.CreateTemp
ioutil.WriteFile -> os.WriteFile

*/

//1.指定配置文件路径
//之所以写成全局变量是为了修改配置文件时也能直接使用
const ConfigFile = "settings.yaml"

// InitConf 读取yaml文件的配置
func InitConf() {
	//ps:因为日志的初始化要先读配置文件，所以这个方法内无法使用global.Log

	//关联到我们的配置文件结构体
	c := &config.Config{}

	yamlConf, err := os.ReadFile(ConfigFile)
	if err != nil {
		panic(fmt.Errorf("get yamlConf error: %s", err))
	}
	err = yaml.Unmarshal(yamlConf, c)
	if err != nil {
		log.Fatalf("config Init Unmarshal: %v", err)
	}
	log.Println("config yamlFile load Init success.")

	// fmt.Println(c)
	//全局变量，就是将读取的到配置文件存储为全局变量
	global.Config = c
}
```

加一个 Es 全局变量,在`global\global.go`

> 变量的类型来源自对应源码

```go
package global

import (
	"gvb_server/config"

	"github.com/olivere/elastic/v7"
	"github.com/redis/go-redis/v9"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var (
	// 配置文件全局变量
	Config *config.Config
	//数据库全局变量
	DB     *gorm.DB
	//日志全局变量
	Log *logrus.Logger
	//全局mysql日志
	MysqlLog logger.Interface
	//全局redis
	Redis *redis.Client
	//全局es
	ESClient *elastic.Client
)
```

然后书写连接方法并将实例挂载到全局变量

```go
package core

import (
	"gvb_server/global"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func EsConnect() {
	var err error
    //是否开启集群监听，单机模式需要关闭
	sniffOpt := elastic.SetSniff(false)
	c, err := elastic.NewClient(
		//读取封装好的Es配置
		elastic.SetURL(global.Config.Es.URL()),
		sniffOpt,
		elastic.SetBasicAuth(global.Config.Es.Username, global.Config.Es.Password),
	)
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	//连接成功后将es实例赋值给全局的变量
	global.ESClient = c
}
```

最后在`main.go`入口函数中启用 es

```go
package main

import (
	"gvb_server/core"
	_ "gvb_server/docs" // swag init生成后的docs路径
	"gvb_server/flag"
	"gvb_server/global"
	"gvb_server/routers"
)

// @title API文档
// @version 1.0
// @description API文档
// @host 127.0.0.01:9000
// @BasePath /
func main() {
	// 执行读取配置文件的操作
	core.InitConf()
	//查看配置文件全局变量
	// fmt.Println(global.Config)

	//初始化日志
	global.Log = core.InitLogger()
	//测试全局日志
	// global.Log.Warnln("警告")
	// global.Log.Error("错误")
	// global.Log.Info("信息")

	//连接数据库，注册数据库实例
	global.DB = core.InitGorm()
	// fmt.Println(global.DB)


	//初始化redis
	global.Redis = core.ConnectRedis()

	//初始化es
	core.EsConnect()


	//命令行参数绑定
	// go run main.go -db
	//如果在者停止了web服务，后面有关web的就不该执行
	option := flag.Parse()
	if flag.IsWebStop(option){
		flag.SwitchOption(option)
		return
	}

	//注册路由
	router := routers.InitRouter()
	// 根据system配置来设定监听目标
	addr:=global.Config.System.Addr()
	global.Log.Info("gvb_server正在监听:%s",addr)
	err :=router.Run(addr)
	if(err!=nil){
		global.Log.Fatalf(err.Error())
	}
}
```

## Flag 命令创建 es 表结构

在`flag/es.go`

```go
package flag

import (
	"fmt"
	"gvb_server/models"
)

func EsCreateIndex() {
	err := models.ArticleModel{}.CreateIndex()
	if err!=nil{
		fmt.Println("创建es索引失败")
	}
}
```

在`flag\enter.go`对命令进行分发

```go
package flag

import (
	sys_flag "flag"

	"github.com/fatih/structs"
)

type Option struct {
  DB bool
  /*
    预计形式 -u admin 就是admin用户，user就是普通用户
  */
  User string
  /*
    -es create 创建索引
    -es delete 删除索引
  */
  Es string
}

// Parse 解析命令行参数
func Parse() Option {
  db := sys_flag.Bool("db", false, "初始化数据库")
  user:= sys_flag.String("u","","创建用户")
  es := sys_flag.String("es","","es操作")
  // 解析命令行参数写入注册的flag里
  sys_flag.Parse()
  return Option{
    DB: *db,
    User: *user,
    Es:*es,
  }
}

// IsWebStop 是否停止web项目
func IsWebStop(option Option) (f bool) {
  maps := structs.Map(&option)
  for _, v := range maps {
    switch val := v.(type) {
    case string:
      if val != "" {
        f = true
      }
    case bool:
      if val == true {
        f = true
      }
    }
  }
  return f
}

// SwitchOption 根据命令执行不同的函数
func SwitchOption(option Option) {
  if option.DB {
    Makemigrations()
    return
  }

  if option.User =="admin"||option.User =="user" {
    CreateUser(option.User)
    return
  }

  //在这里解析值，例如 -es create
  //实际上键是es 值是es后面跟的内容
  if option.Es == "create"{
    EsCreateIndex()
      return
  }

  //前面的return不要忘记
  //不符合预期走这里
  sys_flag.Usage()
}
```

**命令执行**

```sh
go run main.go -es create
```

# 文章管理

**关于文章管理的一些解读**

```sh
文章管理这一块，传统的做法可以采取MySql查询的方式，例如将文章内容存在一个或多个字段，然后做模糊查询，但是效率极低。

所以这次采用ES，未来好做全文搜索。
```

## 建立表结构

`article_model.go`

文章表结构

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

`comment_model.go`

评论的表结构

```go
package models

// CommentModel 评论表
type CommentModel struct {
	MODEL              `json:",select(c)"`
    //子评论列表
	SubComments        []CommentModel `gorm:"foreignkey:ParentCommentID" json:"sub_comments,select(c)"`
    // 父级评论
	ParentCommentModel *CommentModel  `gorm:"foreignkey:ParentCommentID" json:"comment_model"`
    // 父评论id
	ParentCommentID    *uint          `json:"parent_comment_id,select(c)"`
    // 评论内容
	Content            string         `gorm:"size:256" json:"content,select(c)"`
    // 点赞数
	UpvoteCount          int            `gorm:"size:8;default:0;" json:"upvote_count,select(c)"`
    // 子评论数
	CommentCount       int            `gorm:"size:8;default:0;" json:"comment_count,select(c)"`
    // 文章id
	ArticleID          string         `gorm:"size:32" json:"article_id,select(c)"`
    // 关联的用户
	User               UserModel      `json:"user,select(c)"`
    // 评论的用户
	UserID             uint           `json:"user_id,select(c)"`
}
```

## 文章表 Model 的 ES 相关设置

```go
package models

import (
	"gvb_server/models/ctype"
)

type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}

//建立ES索引
func (ArticleModel) Index() string {
	return "article_index"
}

//对应mapping，要与model形成映射
func (ArticleModel) Mapping() string {
  return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text"
      },
      "keyword": {
        "type": "keyword"
      },
      "abstract": {
        "type": "text"
      },
      "content": {
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "upvote_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": {
        "type": "text"
      },
      "user_avatar": {
        "type": "text"
      },
      "category": {
        "type": "text"
      },
      "source": {
        "type": "text"
      },
      "link": {
        "type": "text"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": {
        "type": "text"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}

// IndexExists 索引是否存在
func (a ArticleModel) IndexExists() bool {
  exists, err := global.ESClient.
    IndexExists(a.Index()).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return exists
  }
  return exists
}

// CreateIndex 创建索引
func (a ArticleModel) CreateIndex() error {
  if a.IndexExists() {
    // 有索引
    a.RemoveIndex()
  }
  // 没有索引
  // 创建索引
  createIndex, err := global.ESClient.
    CreateIndex(a.Index()).
    BodyString(a.Mapping()).
    Do(context.Background())
  if err != nil {
    logrus.Error("创建索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !createIndex.Acknowledged {
    logrus.Error("创建失败")
    return err
  }
  logrus.Infof("索引 %s 创建成功", a.Index())
  return nil
}

// RemoveIndex 删除索引
func (a ArticleModel) RemoveIndex() error {
  logrus.Info("索引存在，删除索引")
  // 删除索引
  indexDelete, err := global.ESClient.DeleteIndex(a.Index()).Do(context.Background())
  if err != nil {
    logrus.Error("删除索引失败")
    logrus.Error(err.Error())
    return err
  }
  if !indexDelete.Acknowledged {
    logrus.Error("删除索引失败")
    return err
  }
  logrus.Info("索引删除成功")
  return nil
}

// Create 添加的方法
func (a ArticleModel) Create() (err error) {
  indexResponse, err := global.ESClient.Index().
    Index(a.Index()).
    BodyJson(a).Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return err
  }
  a.ID = indexResponse.Id
  return nil
}

// ISExistData 是否存在该文章
func (a ArticleModel) ISExistData() bool {
  res, err := global.ESClient.
    Search(a.Index()).
    Query(elastic.NewTermQuery("keyword", a.Title)).
    Size(1).
    Do(context.Background())
  if err != nil {
    logrus.Error(err.Error())
    return false
  }
  if res.Hits.TotalHits.Value > 0 {
    return true
  }
  return false
}
```

## 添加文章

需要前端传递的数据

```go
type ArticleRequest struct {
	Title    string      `json:"title" binding:"required" msg:"文章标题必填"`   // 文章标题
	Abstract string      `json:"abstract"`                                // 文章简介
	Content  string      `json:"content" binding:"required" msg:"文章内容必填"` // 文章内容
	Category string      `json:"category"`                                // 文章分类
	Source   string      `json:"source"`                                  // 文章来源
	Link     string      `json:"link"`                                    // 原文链接
	BannerID uint        `json:"bannerId"`                               // 文章封面id
	Tags     ctype.Array `json:"tags"`                                    // 文章标签
}
```

文章封面如果没传就随机在选

### **1.从 token 拿取用户数据**

```go
package article_api

import (
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
}
```

### 2.content 处理

1.对文章内容的校验，例如

```sh
防范xss攻击
```

2.文章简介的逻辑

如果文章简介没传，就默认选文章内容的前 30 个字符

这里要考虑到中文字符截取和其他字符不同，

> 推荐搜索:golang 字符串的截取

```go
func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName

	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(cr.Content)
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	}
}
```

3.查询 banner 信息

逻辑:查询 banner，

待优化:如果没有 bannerId 就随机从后台选一张

```go

// 查banner_id下的banner_url
var bannerUrl string

err = global.DB.Model(models.BannerModel{})
	.Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error

if err != nil {
    res.FailWithMessage("banner不存在", c)
    return
}
```

### 3.获取用户头像

```go
 // 查用户头像
  var avatar string
  err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
  if err != nil {
    res.FailWithMessage("用户不存在", c)
    return
  }
```

### 4.发布文章

我们在 model 上挂载创建文章的方法

```go
// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(a).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

然后调用该方法发布文章

```go
//获取当前时间并格式化
now := time.Now().Format("2006-01-02 15:04:05")
//实例化
article := models.ArticleModel{
    CreatedAt:    now,
    UpdatedAt:    now,
    Title:        cr.Title,
    Abstract:     cr.Abstract,
    Content:      cr.Content,
    UserID:       userID,
    UserNickName: userNickName,
    UserAvatar:   avatar,
    Category:     cr.Category,
    Source:       cr.Source,
    Link:         cr.Link,
    BannerID:     cr.BannerID,
    BannerUrl:    bannerUrl,
    Tags:         cr.Tags,
 }

err = article.Create()
if err != nil {
	global.Log.Error(err)
	res.FailWithMessage(err.Error(), c)
	return
}
res.OkWithMessage("文章发布成功", c)
```

### 5.简易的发布文章接口

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"time"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName

	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(cr.Content)
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	}


	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

### markDown 与 html 互转

#### markDown 转 Html

在我们接收到 content 的时候极有可能是 markdown 格式的，我们先需要转成 html 格式，

###### 测试 demo

````go
package testdata

import (
	"fmt"
	"testing"

	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown转html

func TestMdToHtml(t *testing.T){
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))
}
````

这里使用到的库是

```sh
github.com/russross/blackfriday
```

基本用法是

```go
html := blackfriday.MarkdownCommon([]byte(前端传递来的md片段))
```

##### html 获取文本内容

我们从 md 转出的 html 还不能使用，需要进一步转成文本格式，此时要用到一个新的库

```go
github.com/PuerkitoBio/goquery
```

测试 demo 书写如下

````go
package testdata

import (
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown转html

func TestMdToHtml(t *testing.T){
	//将md转html
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))

	//将html转为可读文本格式
	doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	fmt.Println(doc.Text())
}
````

##### xxs 过滤

这一步很简单，只需要我们在 html 转可读文本时过滤掉 script 标签即可，例如

```go
doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
//移除script标签，过滤xxs
doc.Find("script").Remove()
fmt.Println(doc.Text())
```

我们还可以去获取节点

```go
//返回值是一个列表，如果没有就是[]
//如果有值就是[标识符1,标识符2,...]
nodes := doc.Find("h1").Nodes
```

#### html 转 md

我们使用的第三方库

```go
github.com/JohannesKaufmann/html-to-markdown
```

#### **完整测试代码**

````go
package htmlandmdtest

import (
	"fmt"
	"strings"
	"testing"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

//这个文件用于测试markdown与html互转

func TestMdToHtml(t *testing.T){
	//将md转html
	unsafe := blackfriday.MarkdownCommon([]byte("### 你好\n ```python\nprint('你好')\n```\n - 123 \n \n<script>alert(123)</script>\n\n ![图片](http://xxx.com)"))
	fmt.Println(string(unsafe))

	//将html转为可读文本格式
	doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	//移除script标签，过滤xxs
	doc.Find("script").Remove()
	fmt.Println(doc.Text())


	//html转md
	converter := md.NewConverter("", true, nil)
	html, _ := doc.Html()
	markdown, err := converter.ConvertString(html)
	fmt.Println(markdown, err)
}
````

### 添加文章优化

#### 1.content 处理

刚才的 content 我们直接存入了 es，那是很不合理的，

```sh
要进行xxs过滤:
1.把前端传递来的markdown形式content转成html
2.进行xxs过滤后再转回markdown，方便前端回显
```

```go
 // 处理content，把markdown转为html
  unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
  doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
  //fmt.Println(doc.Text())
 // 是不是有script标签
  nodes := doc.Find("script").Nodes
  //如果有script标签就过滤掉然后再将过滤后结果转回markdown
  if len(nodes) > 0 {
    // 有script标签
    doc.Find("script").Remove()
    converter := md.NewConverter("", true, nil)
    html, _ := doc.Html()
    markdown, _ := converter.ConvertString(html)
    cr.Content = markdown
  }
```

**理解**

```sh
content始终是前端传递的markdown，如果有xxs，我们就过滤后再转回markdown
```

#### 2.简介的处理

按照我们截取简介的逻辑，就会把 markdown 符号写入简介，所以应该要做处理

```sh
我们不是直接对content进行截取，而是应该截取content转成的html可读文本，所以应该对`doc.Text()`进行截取
```

```go
if cr.Abstract == "" {
    // 汉字的截取不一样
    abs := []rune(doc.Text())
    // 将content转为html，并且过滤xss，以及获取中文内容
    if len(abs) > 100 {
      cr.Abstract = string(abs[:100])
    } else {
      cr.Abstract = string(abs)
    }
  }
```

#### 3.banner 的优化

如果没有 bannerId 就随机从后台选一张，

```sh
go语言中有两个包提供了rand，分别为 "math/rand" 和 "crypto/rand", 对应两种应用场景。
一、"math/rand" 包实现了伪随机数生成器。也就是生成 整形和浮点型
二、”crypto/rand“ 包实现了用于加解密的更安全的随机数生成器。
```

具体的我们单独开文档讲解，这里使用`math/rand`

```go
// 不传banner_id,后台就随机去选择一张
  if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
      res.FailWithMessage("没有banner数据", c)
      return
    }
    rand.Seed(time.Now().UnixNano())
    cr.BannerID = bannerIDList[rand.Intn(len(bannerIDList))]
  }
```

注意从 go 1.20 开始，`math/rand`包已经升级到`math/rand/v2`，

```sh
1.删除 Rand.Read 和顶层的 Read。
2.移除 Source.Seed、Rand.Seed 和顶层 Seed。（意味着像 Int 这样的顶层函数将总是随机播种）
3.移除 Source64，现在 Source 提供了 Uint64 方法，原有的方法没有必要存在了。
4.在 Float32 和 Float64 中使用更直接的实现。以 Float64 为例，它最初使用 float64(r.Int63()) / (1<<63)。但这有一个问题，就是偶尔会四舍五入到 1.0，而 Float64 一定不会。我们期望改成 float64(r.Int63n(1<<53)) / (1<<53)，这就避免了四舍五入的问题。

5.用 Rand.Shuffle 的方式实现 Rand.Perm。Shuffle 的效率更高一些，这样可以确保只有一个实现。
6.将 Int31、Int31n、Int63、Int64n 更名为 Int32、Int32n、Int64、Int64n。这些名字是不必要的迂腐和混乱。
7.添加 Uint32, Uint32n, Uint64, Uint64n, Uint, Uintn，将会是 Rand 上的顶级函数和方法。
8.在 Intn, Uintn, Int32n, Uint32n, Int64n, Uint64n 中使用 Lemire 的算法。性能会有新的突破。
9.添加一个新的 Source 实现，PCG-DXSM。包含：NewPCG 等相关 API 可以调用。
10.删除 Mitchell & Reeds LFSR 生成器和 NewSource。
```

所以新的写法

```go
//获得一个rand.Rand源
r:=rand.New(rand.NewSource(time.Now().UnixNano()))
//生成[0,10)之间的int数
r.Intn(10)
```

所以我们的随机取 banner 可以改为

```go
// 不传banner_id,后台就随机去选择一张
if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
        res.FailWithMessage("没有banner数据", c)
        return
    }

    //go 1.22设立随机源
    //然后调用随机源上的方法
    r:=rand.New(rand.NewSource(time.Now().UnixNano()))
    cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
}
```

##### 关于随机数

```go
package rand_test

import (
	"fmt"
	"testing"
	"time"

	"math/rand"
)

func TestRandom(t *testing.T) {
	//go 1.22设立随机源
	//设立随机种子，这里采用秒级时间戳
	src := rand.NewSource(time.Now().UnixNano())
	fmt.Println(time.Now().UnixNano())
	//注册种子生成实例
    r := rand.New(src)
	//获取[0,100]的随机整数
    number := r.Intn(100)
    fmt.Println(number)
}
```

**为什么要设立随机种子**

因为只有种子不同我们才能得到不一样的随机数，否则将获得恒定值

```go
//只有rand实例的种子值不同，才可能获得不同的随机数
number := r.Intn(100)
```

**如何设立随机种子**

我们采用时间戳来作为种子，时间戳随着时间变化，每秒都不同，能满足我们的需求

```go
//设立随机种子，这里采用秒级时间戳
//这一步是生成source类型的值，因为New实例只接收该类型
src := rand.NewSource(time.Now().UnixNano())
//注册种子生成实例
r := rand.New(src)
```

##### **测试缓存的问题**

我们在测试的时候发现时间戳不会产生变化，例如

```go
func TestRandom(t *testing.T) {
	//打印时间戳一直不变
	fmt.Println(time.Now().UnixNano())
}
```

观察输出结果

```go
=== RUN   TestRandom
1721627055350958600
--- PASS: TestRandom (0.00s)
PASS
ok      gvb_server/testdata/rand_test   (cached)
```

这是因为除了第一次的输出结果，后续都采用了`cached`，也就是走了缓存，所以我们不能直接

```sh
go test
```

要不走缓存，我们需要加入`-count=1`,

```sh
# 执行这个目录下的所有测试方法
go test -v -count=1
```

如果只想运行其中的一个用例，例如 `TestRandom`，可以用 `-run` 参数指定，该参数支持通配符 `*`，和部分正则表达式，例如 `^`、`$`

```sh
go test -v -count=1 -run TestRandom
```

**解决方案汇总**

当`go test`以包列表模式运行时，`go test`会缓存成功的包的测试结果以避免不必要的重复测试。当然，有时候我们测试的时候并不喜欢有缓存，我们可以手动禁用缓存。可以通过下列方式禁用缓存：

- 带上-count=1 参数禁用缓存。

  如，执行下面命令测试，便会禁用缓存测试结果

```go
go test -v -count=1 filename_test.go
```

- 手动清除测试缓存

除了在执行测试命令的时候加上禁用缓存参数，我们还可以执行下面的命令手动清除缓存，需要注 意的是，每次都得清除，不然下次执行的还是上次的结果。

```go
go clean -testcache
```

- 环境变量设置法

除了上面两种方式，还可以通过环境变量来改变。我们只需要设置 GOCACHE=off 即可禁用缓存，不过这样执行测试命令的时候会明显感觉有点慢，这很正常，肯定没有直接用缓存的结果快。但我对比了第一种方式，发现加行-count=1 参数这种方式比设置环境变量这种效率要高，速度要快点。

所以，在用 golang 测试，千万不要只仅仅用 go test 就完了，必要时还得加上需要的参数，有些或许连-v 参数都不会加，事实上这样是不会打印出 log 日志的。加上-count 就更完美了。

```go
go test -v -count=1 filename_test.go
```

在 VsCode 中要起效，也是需要在设置中加上此参数的。如下：

```bash
 "go.testFlags": ["-v","-count=1"]
```

##### 关于零值问题

我们判断没有传 bannerId 时使用了

```go
if cr.BannerID == 0 {
    var bannerIDList []uint
    global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
    if len(bannerIDList) == 0 {
        res.FailWithMessage("没有banner数据", c)
        return
    }

    //go 1.22设立随机源
    //然后调用随机源上的方法
    r:=rand.New(rand.NewSource(time.Now().UnixNano()))
    cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
}
```

之所以`cr.BannerId == 0`，是因为 bannerId 是整形，其零值为 0，但我们没有传递时将默认采用零值，所以在数据设计时要排除零值数据。

#### 4.es 索引优化

我们在执行 es 入库操作的时候有几个关键点必不可少。

```sh
1.插入es数据前必须确定文章标题存在，因为我们要通过文章标题来判断两篇文章是否一样(机器和人不一样，当然我们也能通过重复度来判断是否一样，但是那样过于复杂，且我们没有查重的需求)
2.得有一个keyword字段，其类型也是keyword
```

**model 的修改**

加入了 keyword 关键字字段,这个字段存的实际上就是 title，原因

```sh
我们在es中的title是text类型，只能模糊匹配，所以需要一个单独的字段存title，然后设立精确判断类型，好用于做唯一性判断

注:这本质上不是es的问题，而是我们采用的第三方库的问题
```

代码修改

```go
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword",omit(list) structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

**2.es 对应 map 修改**

需要精确匹配的都需要使用 keyword 类型

```go
func (ArticleModel) Mapping() string {
	return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text"
      },
      "keyword": {
        "type": "keyword"
      },
      "abstract": {
        "type": "text"
      },
      "content": {
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "upvote_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": {
        "type": "keyword"
      },
      "user_avatar": {
        "type": "keyword"
      },
      "category": {
        "type": "keyword"
      },
      "source": {
        "type": "keyword"
      },
      "link": {
        "type": "keyword"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": {
        "type": "keyword"
      },
      "tags": {
        "type": "keyword"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}
```

**3.封装判断唯一性的方法**

通过精确匹配 keyword 来判断文章是否存在

```go
// ISExistData 是否存在该文章
func (a ArticleModel) ISExistData() bool {
	//NewTermQuery(key,value) 精确匹配键值
	res, err := global.ESClient.
		Search(a.Index()).
		Query(elastic.NewTermQuery("keyword", a.Title)).
		Size(1).
		Do(context.Background())
    //这里报错，虽然是操作es出错了，但我们也认为是没存在文章
	//错误根据错误捕捉来人工修改
	if err != nil {
		logrus.Error(err.Error())
		return false
	}
    //查询结果
	if res.Hits.TotalHits.Value > 0 {
		return true
	}
	return false
}
```

> 心得:写方法时搞清楚方法的具体需求，我们只要根据需求实现对应内容即可，至于很多额外的错误，通过抛出错误来后期定位，例如这里的 es 报错，我们的目的是判断文章是否存在，即使报错也应该认为不存在，然后通过抛出错误来定位修复即可

**4.添加文章接口的使用**

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))

	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

#### 添加文章优化后的代码

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))

	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

后续的优化空间，可以借助 service 层将复杂逻辑抽离。

## 文章列表

一共有两个地方需要请求文章列表接口，

```sh
后台的文章列表管理界面
前端的文章列表展示界面
```

共同点

```sh
不需要展示文章内容，因为前端文章列表展示界面只要简介就可以，所以不需要把复杂的内容展示出来
```

### 简易的获取文章列表

我们先封装一个 service，从 es 中分页获取数据，例如

`service/es_ser/enter.go`

```go
package es_ser

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func CommList(key string, page int, limit int)(list []models.ArticleModel,count int,err error){
	boolSearch := elastic.NewBoolQuery()
	from := page
	if key != "" {
	  boolSearch.Must(
		//查询title值为key的数据，由于我们的title设置为text类型，所以支持模糊查询
		elastic.NewMatchQuery("title", key),
	  )
	}
	if limit == 0 {
	  limit = 10
	}
	if from == 0 {
	  from = 1
	}

	res, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Query(boolSearch).
    From((from - 1) * limit).
    Size(limit).
    Do(context.Background())

	if err != nil {
		logrus.Error(err.Error())
		return nil,0,err
	}

	count = int(res.Hits.TotalHits.Value) //搜索到结果总条数
	demoList := []models.ArticleModel{}
	for _,hit := range res.Hits.Hits{
		var model models.ArticleModel
		data,err := hit.Source.MarshalJSON()
		if err!=nil{
			logrus.Error(err.Error())
			continue
		}

		err = json.Unmarshal(data,&model)
		if err!=nil{
			logrus.Error(err)
		}
		model.ID = hit.Id
		demoList = append(demoList, model)
	}
	fmt.Println(demoList,count)
	return demoList,count,err
}
```

在获取文章列表的接口进行使用

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
)

func (ArticleApi) ArticleListView(c *gin.Context) {
	var cr models.PageInfo
	err := c.ShouldBindQuery(&cr)
	if err != nil {
	  res.FailWithCode(res.ArgumentError, c)
	  return
	}
	list,count,err := es_ser.CommList(cr.Key,cr.Page,cr.Limit)
	if err != nil{
		global.Log.Error(err)
		res.FailWithMessage("查询失败",c)
	}
	res.OkWithList(list,int64(count),c)
}
```

### 移除文章内容字段

#### es 方案

在 es 的列表查询中过滤掉 content，这种方式最简单，但是会导致方法复用性低

```go
//注意这里面的FetchSourceContext,我们在里面写了过滤文章内容字段的逻辑
res, err := global.ESClient.
Search(models.ArticleModel{}.Index()).
Query(boolSearch).
FetchSourceContext(elastic.NewFetchSourceContext(true).Exclude("content")).
From((from - 1) * limit).
Size(limit).
Do(context.Background())
```

完整代码

```go
package es_ser

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func CommList(key string, page int, limit int)(list []models.ArticleModel,count int,err error){
	boolSearch := elastic.NewBoolQuery()
	from := page
	if key != "" {
	  boolSearch.Must(
		//查询title值为key的数据，由于我们的title设置为text类型，所以支持模糊查询
		elastic.NewMatchQuery("title", key),
	  )
	}
	if limit == 0 {
	  limit = 10
	}
	if from == 0 {
	  from = 1
	}

	//注意这里面的FetchSourceContext,我们在里面写了过滤文章内容字段的逻辑
	res, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Query(boolSearch).
    FetchSourceContext(elastic.NewFetchSourceContext(true).Exclude("content")).
    From((from - 1) * limit).
    Size(limit).
    Do(context.Background())

	if err != nil {
		logrus.Error(err.Error())
		return nil,0,err
	}

	count = int(res.Hits.TotalHits.Value) //搜索到结果总条数
	demoList := []models.ArticleModel{}
	for _,hit := range res.Hits.Hits{
		var model models.ArticleModel
		data,err := hit.Source.MarshalJSON()
		if err!=nil{
			logrus.Error(err.Error())
			continue
		}

		err = json.Unmarshal(data,&model)
		if err!=nil{
			logrus.Error(err)
		}
		model.ID = hit.Id
		demoList = append(demoList, model)
	}
	fmt.Println(demoList,count)
	return demoList,count,err
}
```

#### 结构体方案

我们按照之前的写法会再写一个结构体，然后将文章内容字段除外，例如

```go
type ArticleListRequest struct{
    Title    string      `json:"title" binding:"required" msg:"文章标题必填"`   // 文章标题
	Abstract string      `json:"abstract"`                                // 文章简介
	Category string      `json:"category"`                                // 文章分类
	Source   string      `json:"source"`                                  // 文章来源
	Link     string      `json:"link"`                                    // 原文链接
	BannerID uint        `json:"bannerId"`                               // 文章封面id
	Tags     ctype.Array `json:"tags"`                                    // 文章标签
}
```

但是这样写很麻烦，因为每次有不同我们都要重新写结构体

#### **json-filter 方案**

一个很好用的 json 序列化第三方包

```sh
github.com/liu-cn/json-filter/filter
```

可以按不同的场景去过滤要渲染的 json 字段，可以选择，也可以排查

##### json-filter 的使用

```go
package jsonfilter_test

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/liu-cn/json-filter/filter"
)

type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile)"`
	Price      string    `json:"price,select(profile)"`
}

func TestJsonFilter(t *testing.T){
	user := User{
		UID:        1,
		Nickname:   "boyan",
		Avatar:     "avatar",
		Sex:        1,
		VipEndTime: time.Now().Add(time.Hour * 24 * 365),
		Price:      "999.9",
	  }
	  marshal, err := json.Marshal(user)
	  if err != nil {
		panic(err)
	  }

	  //{"uid":1,"nickname":"boyan","avatar":"avatar","sex":1,"vip_end_time":"2023-03-06T23:11:22.622693+08:00","price":"999.9"}
	  fmt.Println(string(marshal))

	  //{"avatar":"avatar","nickname":"boyan","uid":1}
	  fmt.Println(filter.Select("article", user))

	  //{"nickname":"boyan","price":"999.9","sex":1,"vip_end_time":"2023-03-06T23:31:28.636529+08:00"}
	  fmt.Println(filter.Select("profile", user))
	  //{"nickname":"boyan"}
	  fmt.Println(filter.Select("list", user))
	  fmt.Println(filter.Omit("vip", user))
}
```

**1.用 select 对 json 进行分组**

基本语法

```sh
type 结构体名 struct{
	字段1 字段类型  `json:"对应json字符,select(组1|组2)"`
}
```

示例

```go
type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile)"`
	Price      string    `json:"price,select(profile)"`
}
```

在返回结构体时将返回该组的字段

```go
fmt.Println(filter.Select(组名, 结构体))

//只操作该组的json，例如uid、avatar、nickname
fmt.Println(filter.Select("article", user))
```

**2.omit 排除某个字段**

```go
type User struct {
	UID        uint      `json:"uid,select(article)"`
	Avatar     string    `json:"avatar,select(article)"`
	Nickname   string    `json:"nickname,select(article|profile|list)"`
	Sex        int       `json:"sex,select(profile)"`
	VipEndTime time.Time `json:"vip_end_time,select(profile),omit(vip)"`
	Price      string    `json:"price,select(profile)"`
  }
```

添加排除分组，但我们使用这个组时包含该组名的字段将被排除

```go
//例如vip_end_time将被排除
fmt.Println(filter.Omit("vip", user))
```

更多使用可以去查看`docs`下的 json-filter 文档

##### 项目中使用

我们在 article_model 中过滤掉

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content",omit(list) structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

然后在查询结果中进行使用

```go
func (ArticleApi) ArticleListView(c *gin.Context) {
  var cr models.PageInfo
  if err := c.ShouldBindQuery(&cr); err != nil {
    res.FailWithCode(res.ArgumentError, c)
    return
  }
  list, count, err := es_ser.CommList(cr.Key, cr.Page, cr.Limit)
  if err != nil {
    global.Log.Error(err)
    res.OkWithMessage("查询失败", c)
    return
  }

  //对返回的结构体进行过滤
  res.OkWithList(filter.Omit("list", list), int64(count), c)
}
```

## 文章详情

### 通过 es 的 id 查询

需求

```sh
1.根据文章的es的id去查询对应的文章详情,然后在前端网页显示
```

service 层获取 es 详情

```go
//根据id获取es详情
func CommDetail(id string) (model models.ArticleModel, err error) {

	res, err := global.ESClient.Get().
	  Index(models.ArticleModel{}.Index()).
	  Id(id).
	  Do(context.Background())

	if err != nil {
	  return
	}
	err = json.Unmarshal(res.Source, &model)
	if err != nil {
	  return
	}
	model.ID = res.Id
	return
}
```

获取文章详情的接口

```go
package article_api

import (
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
)

type ESIDRequest struct {
	ID string `json:"id" form:"id" uri:"id"`
}

func (ArticleApi) ArticleDetailView(c *gin.Context) {
	var cr ESIDRequest
	err := c.ShouldBindUri(&cr)
	if err != nil {
	  res.FailWithCode(res.ArgumentError, c)
	  return
	}
	model, err := es_ser.CommDetail(cr.ID)
	if err != nil {
	  res.FailWithMessage(err.Error(), c)
	  return
	}
	res.OkWithData(model, c)
  }
```

### 通过文章 title 来查询

由于我们设立了 keyword 来存储文章 title，且该字段精确匹配，所以我们可以实现通过文章标题来获取数据

**封装 service 方法**

```go
package es_ser

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

//根据keyword，即文章标题获取文章详情
func CommDetailByKeyword(key string) (model models.ArticleModel, err error) {
	res, err := global.ESClient.Search().
	  Index(models.ArticleModel{}.Index()).
	  Query(elastic.NewTermQuery("keyword", key)).
	  Size(1).
	  Do(context.Background())
	if err != nil {
	  return
	}
	if res.Hits.TotalHits.Value == 0 {
	  return model, errors.New("文章不存在")
	}
	hit := res.Hits.Hits[0]

	err = json.Unmarshal(hit.Source, &model)
	if err != nil {
	  return
	}
	model.ID = hit.Id
	return
}
```

## 文章日历

### 文章时间聚合搜索

这里的核心是 es 的时间聚合，我们这里按照天去聚合

```sh
什么是聚合
实际上就和mysql中的group by等的功能类似，就是做分组
```

#### 根据小时分组的 demo

这里贴一下 es 查询的源码

```json
POST /sales/_search?size=0
{
    "aggs" : {
        // 聚合查询名字，随便取一个
        "sales_over_time" : {
            // 聚合类型为: date_histogram
            "date_histogram" : {
                // 根据date字段分组
                "field" : "date",
                // 分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年）
                "calendar_interval" : "month",
                "format" : "yyyy-MM-dd" // 设置返回结果中桶key的时间格式
            }
        }
    }
}
```

贴一张结果

```go
{
"took": 2,
"timed_out": false,
"_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
},
"hits": {
    "total": {
        "value": 3,
        "relation": "eq"
    },
    "max_score": null,
    "hits": [ ]
},
"aggregations": {
    "my_name": {
        "buckets": [
            {
                "key_as_string": "2024-07-23 15:21:00",
                "key": 1721748060000,
                "doc_count": 1
            },
            {
                "key_as_string": "2024-07-23 15:22:00",
                "key": 1721748120000,
                "doc_count": 2
            }
        	]
        }
    }
}
```

go 的测试代码

```go
package elasticSearch_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)
type BucketsType struct {
	Buckets []struct {
	  KeyAsString string `json:"key_as_string"`
	  Key         int64  `json:"key"`
	  DocCount    int    `json:"doc_count"`
	} `json:"buckets"`
}
func TestDateAgg(t *testing.T) {
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()
	// 创DateHistogram桶聚合
	aggs := elastic.NewDateHistogramAggregation().
	Field("created_at"). // 根据date字段值，对数据进行分组
	//  分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年)
	CalendarInterval("minute").
	// 设置返回结果中桶key的时间格式
	Format("yyyy-MM-dd")

	searchResult, err := client.Search().
	Index("article_index"). // 设置索引名
	Query(elastic.NewMatchAllQuery()). // 设置查询条件
	Aggregation("sales_over_time", aggs). // 设置聚合条件，并为聚合条件设置一个名字
	Size(0). // 设置分页参数 - 每页大小,设置为0代表不返回搜索结果，仅返回聚合分析结果
	Do(ctx) // 执行请求

	if err != nil {
		// Handle error
		panic(err)
	}

	// 使用DateHistogram函数和前面定义的聚合条件名称，查询结果
	agg, found := searchResult.Aggregations.DateHistogram("sales_over_time")
	if !found {
		logrus.Fatal("没有找到聚合数据")
	}
    if len(agg.Buckets)==0{
		logrus.Fatal("没有待展示的数据")
	}
	// 遍历桶数据
	for _, bucket := range agg.Buckets {
		// 每一个桶都有一个key值，其实就是分组的值，可以理解为SQL的group by值
		bucketValue := bucket.Key

		// 打印结果， 默认桶聚合查询，都是统计文档总数
		fmt.Printf("bucket = %v 文档总数 = %d\n", bucketValue, bucket.DocCount)
	}
}
```

上述测试代码是一种方案，另一种是直接从聚类分析结果的 Aggregations 属性上读取，这个属性是个`map[string]any`,键就是我们使用 Aggregation()传入的第一个参数，对应值就是查询结果，不过由于结果是字节切片，需要使用字符串转化，例如

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

func (ArticleApi) ArticleCalendarView(c *gin.Context) {
	// 时间聚合函数
	//field按照哪个字段聚合
	//CalendarInterval按照什么维度聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")

	//Aggregation(键名,聚合函数)
	result, err := global.ESClient.
	Search(models.ArticleModel{}.Index()).
	Query(elastic.NewMatchAllQuery()).
	Aggregation("calendar", agg).
	Size(0).
	Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("查询失败", c)
		return
	}
	//result.Aggregations["calendar"]是一个byte切片
	//要转成string才可读
	fmt.Println(string(result.Aggregations["calendar"]))
}
```

**难点小结**

```sh
实际上方法并不难，问题出在后文问题总结所说，在插入es数据时发生了错误，导致我们正确聚类。
```

### 时间段搜索

指定聚合搜索的时间段，例如从今天到去年今天

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

func (ArticleApi) ArticleCalendarView(c *gin.Context) {

	// 时间聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")

	// 时间段搜索
	// 从今天开始，到去年的今天
	now := time.Now()
	//获取一年前的时间
	aYearAgo := now.AddDate(-1, 0, 0)
	fmt.Println("一年前时间",aYearAgo)

	format := "2006-01-02 15:04:05"
	// lt 小于  gt 大于
    //时间使用format的原因是因为我们存入的created_at也使用了格式化，为了方便比较，应该格式化为同一格式
	query := elastic.NewRangeQuery("created_at").
	  Gte(aYearAgo.Format(format)).
	  Lte(now.Format(format))

	result, err := global.ESClient.
	  Search(models.ArticleModel{}.Index()).
	  Query(query).
	  Aggregation("calendar", agg).
	  Size(0).
	  Do(context.Background())
	if err != nil {
	  global.Log.Error(err)
	  res.FailWithMessage("查询失败", c)
	  return
	}

	fmt.Printf("查询结果为%#v",string(result.Aggregations["calendar"]))
}
```

要返回给前端的格式如下

```json
dateList:[
    {date:"2023-12-14",count:1},
    {date:"2024-05-01",count:5}
]
```

所以构造结构体

```go
//用于构造响应数据
type CalendarResponse struct {
  Date  string `json:"date"`
  Count int    `json:"count"`
}

//用于解析获取es的结果
type BucketsType struct {
  Buckets []struct {
    KeyAsString string `json:"key_as_string"`
    Key         int64  `json:"key"`
    DocCount    int    `json:"doc_count"`
  } `json:"buckets"`
}
```

解析 es 结果

```go
//构造出一种格式{时间字符串:count}
//这样可以配合时间遍历获得单天的count
var DateCount = map[string]int{}

(...获取查询结果result)

//将获得的结果映射到json中
var data BucketsType
_ = json.Unmarshal(result.Aggregations["calendar"], &data)

var resList = make([]CalendarResponse, 0)
//将获得的结果，例如
/*
	data.Buckets= [
            {
                "key_as_string": "2024-07-23 15:21:00",
                "key": 1721748060000,
                "doc_count": 1
            },
            {
                "key_as_string": "2024-07-23 15:22:00",
                "key": 1721748120000,
                "doc_count": 2
            }
        	]
     }
*/
for _, bucket := range data.Buckets {
    //按照我们之前的format格式化时间
    Time, _ := time.Parse(format, bucket.KeyAsString)
    //构造 {时间字符串:count}
    DateCount[Time.Format("2006-01-02")] = bucket.DocCount
}
```

现在要构造 CalendarResponse 数据

```go
//now.Sub(aYearAgo).Hours()获得两个时间差之间的总小时数
//除以24获得天数，由于格式是int64，所以我们转换一下
days := int(now.Sub(aYearAgo).Hours() / 24)
//按照天数遍历
for i := 0; i <= days; i++ {
    //格式化每一天，使用AddDate(0, 0, i)获得递增时间序列
    day := aYearAgo.AddDate(0, 0, i).Format("2006-01-02")

    //由于{时间字符串:count}格式，我们可以通过时间获取数据
    count, _ := DateCount[day]
    resList = append(resList, CalendarResponse{
      Date:  day,
      Count: count,
    })
  }
```

**完整代码**

```go
package article_api

import (
	"context"
	"encoding/json"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

/*
	用于构造前端所需数据
	dateList:[
		{date:"2023-12-14",count:1},
		{date:"2024-05-01",count:5}
	]
*/
type CalendarResponse struct {
	Date  string `json:"date"`
	Count int    `json:"count"`
}

//用于解析获取es的结果
type BucketsType struct {
	Buckets []struct {
	  KeyAsString string `json:"key_as_string"`
	  Key         int64  `json:"key"`
	  DocCount    int    `json:"doc_count"`
	} `json:"buckets"`
 }

//构造出一种格式{时间字符串:count}
//这样可以配合时间遍历获得单天的count
var DateCount = map[string]int{}

func (ArticleApi) ArticleCalendarView(c *gin.Context) {

	// 时间聚合
	agg := elastic.NewDateHistogramAggregation().Field("created_at").CalendarInterval("day")

	// 时间段搜索
	// 从今天开始，到去年的今天
	now := time.Now()
	//获取一年前的时间
	aYearAgo := now.AddDate(-1, 0, 0)
	// fmt.Println("一年前时间",aYearAgo)

	format := "2006-01-02 15:04:05"
	// lt 小于  gt 大于
	//时间使用format的原因是因为我们存入的created_at也使用了格式化，为了方便比较，应该格式化为同一格式
	query := elastic.NewRangeQuery("created_at").
	  Gte(aYearAgo.Format(format)).
	  Lte(now.Format(format))

	result, err := global.ESClient.
	  Search(models.ArticleModel{}.Index()).
	  Query(query).
	  Aggregation("calendar", agg).
	  Size(0).
	  Do(context.Background())
	if err != nil {
	  global.Log.Error(err)
	  res.FailWithMessage("查询失败", c)
	  return
	}
	// fmt.Printf("查询结果为%#v",string(result.Aggregations["calendar"]))

	//将获得的结果映射到json中
	var data BucketsType
  	err = json.Unmarshal(result.Aggregations["calendar"], &data)
	if err!=nil{
		global.Log.Error(err)
		res.FailWithMessage("结果解析错误", c)
		return
	}
	//将获得的结果，例如
	/*
		data.Buckets= [
				{
					"key_as_string": "2024-07-23 15:21:00",
					"key": 1721748060000,
					"doc_count": 1
				},
				{
					"key_as_string": "2024-07-23 15:22:00",
					"key": 1721748120000,
					"doc_count": 2
				}
				]
		}
	*/
  	var resList = make([]CalendarResponse, 0)
  	for _, bucket := range data.Buckets {
		//按照我们之前的format格式化时间
		Time, _ := time.Parse(format, bucket.KeyAsString)
		//构造 {时间字符串:count}
		DateCount[Time.Format("2006-01-02")] = bucket.DocCount
  	}

	//now.Sub(aYearAgo).Hours()获得两个时间差之间的总小时数
	//除以24获得天数，由于格式是int64，所以我们转换一下
	days := int(now.Sub(aYearAgo).Hours() / 24)

	//按照天数遍历
	for i := 0; i <= days; i++ {

		//格式化每一天，使用AddDate(0, 0, i)获得递增时间序列
		day := aYearAgo.AddDate(0, 0, i).Format("2006-01-02")

		//由于{时间字符串:count}格式，我们可以通过时间获取数据
		count, _ := DateCount[day]
		resList = append(resList, CalendarResponse{
			Date:  day,
			Count: count,
		})
	}

	res.OkWithData(resList, c)

}
```

## 文章标签管理

### 聚类查询测试

#### 对 tag 进行聚类

我们的目的是要实现如下的标签形式

```json
[
  {
    //标签名
    "tag": "python",
    //文章数量
    "articleCount": 2,
    //文章列表
    "articleList": []
  }
]
```

先可以通过聚合的方式查询 tags

```go
package articletag_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

//连接es
func Connect() (*elastic.Client, error) {
	//连接es
	sniffOpt := elastic.SetSniff(false)
	host := "http://127.0.0.1:9200"
	client, err := elastic.NewClient(
		elastic.SetURL(host),
		sniffOpt,
		elastic.SetBasicAuth("", ""),
	)
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
		return nil, err
	}
	return client, nil
}

func TestTag(t *testing.T) {
	// 我们最终要实现的文章标签形式为
	//[{tag:"python",articleCount:2,articleList:[]}]
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()

	agg := elastic.NewTermsAggregation().Field("tags")
	query := elastic.NewBoolQuery()

	result, err := client.
	  Search("article_index").
	  Query(query).
	  Aggregation("tags", agg).
	  Size(0).
	  Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}

	fmt.Printf("查询结果为%#v",string(result.Aggregations["tags"]))
}
```

查询结果为

```json
{
  "doc_count_error_upper_bound": 0,
  "sum_other_doc_count": 0,
  "buckets": [
    { "key": "后端", "doc_count": 2 },
    { "key": "月计划", "doc_count": 1 },
    { "key": "编程", "doc_count": 1 }
  ]
}
```

#### 子聚类

**进一步聚类每个 key 下面的文章信息**

```go
//按照tags标签聚类
agg := elastic.NewTermsAggregation().Field("tags")
//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
```

**完整测试代码**

```go
func TestTag(t *testing.T) {
	// 我们最终要实现的文章标签形式为
	//[{tag:"python",articleCount:2,articleList:[]}]
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()

	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")
	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
	query := elastic.NewBoolQuery()

	result, err := client.
	  Search("article_index").
	  Query(query).
	  Aggregation("tags", agg).
	  Size(0).
	  Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}

	fmt.Printf("查询结果为%#v",string(result.Aggregations["tags"]))
}
```

**查询结果**

```json
{
  "doc_count_error_upper_bound": 0,
  "sum_other_doc_count": 0,
  "buckets": [
    {
      "key": "后端",
      "doc_count": 2,
      "articles": {
        "doc_count_error_upper_bound": 0,
        "sum_other_doc_count": 0,
        "buckets": [
          { "key": "golang基础", "doc_count": 1 },
          { "key": "node基础", "doc_count": 1 }
        ]
      }
    },
    {
      "key": "月计划",
      "doc_count": 1,
      "articles": {
        "doc_count_error_upper_bound": 0,
        "sum_other_doc_count": 0,
        "buckets": [{ "key": "ps基础", "doc_count": 1 }]
      }
    },
    {
      "key": "编程",
      "doc_count": 1,
      "articles": {
        "doc_count_error_upper_bound": 0,
        "sum_other_doc_count": 0,
        "buckets": [{ "key": "golang基础", "doc_count": 1 }]
      }
    }
  ]
}
```

根据形式构造接收结构体

```go
//返回给前端的
type TagsResponse struct {
  Tag           string   `json:"tag"`
  Count         int      `json:"count"`
  ArticleIDList []string `json:"article_id_list"`
}

//用于接收聚类分析结果的
type TagsType struct {
  DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
  SumOtherDocCount        int `json:"sum_other_doc_count"`
  Buckets                 []struct {
    Key      string `json:"key"`
    DocCount int    `json:"doc_count"`
    Articles struct {
      DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
      SumOtherDocCount        int `json:"sum_other_doc_count"`
      Buckets                 []struct {
        Key      string `json:"key"`
        DocCount int    `json:"doc_count"`
      } `json:"buckets"`
    } `json:"articles"`
  } `json:"buckets"`
}
```

**完整代码**

```go
package articletag_test

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

//返回给前端的
//这是要用结构体映射json，最终json是给前端的所以驼峰
type TagsResponse struct {
	Tag           string   `json:"tag"`
	Count         int      `json:"count"`
	ArticleIDList []string `json:"articleIdList"`
}

//用于接收聚类分析结果的
//这里用于将es分析的结果json转为结构体，所以json映射得和es分析结果类似
//es分析结果是蛇形命名，所以采用蛇形命名映射
type TagsType struct {
	DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
	SumOtherDocCount        int `json:"sum_other_doc_count"`
	Buckets                 []struct {
	  Key      string `json:"key"`
	  DocCount int    `json:"doc_count"`
	  Articles struct {
		DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
		SumOtherDocCount        int `json:"sum_other_doc_count"`
		Buckets                 []struct {
		  Key      string `json:"key"`
		  DocCount int    `json:"doc_count"`
		} `json:"buckets"`
	  } `json:"articles"`
	} `json:"buckets"`
}

//连接es
func Connect() (*elastic.Client, error) {
	//连接es
	sniffOpt := elastic.SetSniff(false)
	host := "http://127.0.0.1:9200"
	client, err := elastic.NewClient(
		elastic.SetURL(host),
		sniffOpt,
		elastic.SetBasicAuth("", ""),
	)
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
		return nil, err
	}
	return client, nil
}

func TestTag(t *testing.T) {
	// 我们最终要实现的文章标签形式为
	//[{tag:"python",articleCount:2,articleList:[]}]
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()

	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")
	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))

    //得到id
	//agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("_id"))
	query := elastic.NewBoolQuery()

	result, err := client.
	  Search("article_index").
	  Query(query).
	  Aggregation("tags", agg).
	  Size(0).
	  Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}

	fmt.Printf("查询结果为%#v\n",string(result.Aggregations["tags"]))
	//根据查询的到聚类结果来构造json数据
	var tagType TagsType
	var tagList = make([]TagsResponse, 0)
	//将聚类结果进行解析和映射
	_ = json.Unmarshal(result.Aggregations["tags"], &tagType)
	for _, bucket := range tagType.Buckets {

		var articleList []string
		for _, s := range bucket.Articles.Buckets {
			articleList = append(articleList, s.Key)
		}

		tagList = append(tagList, TagsResponse{
			Tag:           bucket.Key,
			Count:         bucket.DocCount,
			ArticleIDList: articleList,
		})
	}
	fmt.Printf("获得的标签列表%v\n",tagList)
}
```

最终执行结果

```go
[
    {后端 2 [golang基础 node基础]}
    {月计划 1 [ps基础]}
    {编程 1 [golang基础]}
]
```

这是直接打印结构体的值，返回给前端时做要做 json 映射，为了方便展示还可以进一步查询文章信息，然后将文章详情列表返回。

如果想得到 id 列表，可以将子聚类换为

```go
agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("_id"))
```

#### 文章标签列表接口

根据聚类返回所有数据

```go
package article_api

import (
	"context"
	"encoding/json"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

type TagsResponse struct {
	Tag           string   `json:"tag"`
	Count         int      `json:"count"`
	ArticleIDList []string `json:"articleIdList"`
}

type TagsType struct {
	DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
	SumOtherDocCount        int `json:"sum_other_doc_count"`
	Buckets                 []struct {
		Key      string `json:"key"`
		DocCount int    `json:"doc_count"`
		Articles struct {
			DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
			SumOtherDocCount        int `json:"sum_other_doc_count"`
			Buckets                 []struct {
				Key      string `json:"key"`
				DocCount int    `json:"doc_count"`
			} `json:"buckets"`
		} `json:"articles"`
	} `json:"buckets"`
}

func (ArticleApi) ArticleTagListView(c *gin.Context) {
	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")

	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
	// agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(offset).Size(cr.Limit))

	query := elastic.NewBoolQuery()

	result, err := global.ESClient.
		Search(models.ArticleModel{}.Index()).
		Query(query).
		Aggregation("tags", agg).
		Size(0).
		Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	var tagType TagsType
	var tagList = make([]TagsResponse, 0)
	_ = json.Unmarshal(result.Aggregations["tags"], &tagType)
	for _, bucket := range tagType.Buckets {

		var articleList []string
		for _, s := range bucket.Articles.Buckets {
			articleList = append(articleList, s.Key)
		}

		tagList = append(tagList, TagsResponse{
			Tag:           bucket.Key,
			Count:         bucket.DocCount,
			ArticleIDList: articleList,
		})
	}

	res.OkWithData(tagList, c)
}
```

### 聚类分页并求出总数

我们刚才是获取了所有的数据，可是在实际需求中绝对会有分页，所以这里要实现两个功能

```sh
1.聚合分页
2.聚合后的总数获取
```

#### 分页的操作

分页的操作很简单，就是在聚类的最后再执行一个分页操作

```go
agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(页码).Size(每页条数))
```

**完整代码**

```go
func TestTag(t *testing.T) {
	// 我们最终要实现的文章标签形式为
	//[{tag:"python",articleCount:2,articleList:[]}]
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()

	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")
	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	//得到keyword，也就是标题
	// agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
	//得到id
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("_id"))
	//对数据进行分页，例如查询第1页前2条
	agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(1).Size(2))

	query := elastic.NewBoolQuery()

	result, err := client.
	  Search("article_index").
	  Query(query).
	  Aggregation("tags", agg).
	  Size(0).
	  Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}

	fmt.Printf("查询结果为%#v\n",string(result.Aggregations["tags"]))
	//根据查询的到聚类结果来构造json数据
	var tagType TagsType
	var tagList = make([]TagsResponse, 0)
	//将聚类结果进行解析和映射
	_ = json.Unmarshal(result.Aggregations["tags"], &tagType)
	for _, bucket := range tagType.Buckets {

		var articleList []string
		for _, s := range bucket.Articles.Buckets {
			articleList = append(articleList, s.Key)
		}

		tagList = append(tagList, TagsResponse{
			Tag:           bucket.Key,
			Count:         bucket.DocCount,
			ArticleIDList: articleList,
		})
	}
	fmt.Printf("获得的标签列表%v\n",tagList)
}
```

#### 获取总数

由于上下文的存在，我们只能在分组前单独获取总数，否则子聚类就没法用

```go
result, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Aggregation("mytags", elastic.NewValueCountAggregation().Field("tags")).
    Size(0).
    Do(context.Background())
cTag, _ := result.Aggregations.Cardinality("mytags")
count := int64(*cTag.Value)
```

**测试代码**

```go
func TestTag(t *testing.T) {
	// 我们最终要实现的文章标签形式为
	//[{tag:"python",articleCount:2,articleList:[]}]
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	ctx := context.Background()

	//查询总数
	result, err := client.
    Search(models.ArticleModel{}.Index()).
    Aggregation("mytags", elastic.NewValueCountAggregation().Field("tags")).
    Size(0).
    Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}
	cTag, _ := result.Aggregations.Cardinality("mytags")
	count := int64(*cTag.Value)
	fmt.Printf("总数为%d\n",count)

	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")
	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	//得到keyword，也就是标题
	// agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
	//得到id
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("_id"))
	//对数据进行分页，例如查询第1页前2条
	agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(1).Size(2))

	query := elastic.NewBoolQuery()

	result, err = client.
	  Search("article_index").
	  Query(query).
	  Aggregation("tags", agg).
	  Size(0).
	  Do(ctx)

	if err != nil{
		logrus.Error(err)
		return
	}

	fmt.Printf("查询结果为%#v\n",string(result.Aggregations["tags"]))
	//根据查询的到聚类结果来构造json数据
	var tagType TagsType
	var tagList = make([]TagsResponse, 0)
	//将聚类结果进行解析和映射
	_ = json.Unmarshal(result.Aggregations["tags"], &tagType)
	for _, bucket := range tagType.Buckets {

		var articleList []string
		for _, s := range bucket.Articles.Buckets {
			articleList = append(articleList, s.Key)
		}

		tagList = append(tagList, TagsResponse{
			Tag:           bucket.Key,
			Count:         bucket.DocCount,
			ArticleIDList: articleList,
		})
	}
	fmt.Printf("获得的标签列表%v\n",tagList)
}
```

**解读**

```go
//这一行是聚类总数，类似count(tags)
//NewCardinalityAggregation 会对指标进行去重
//NewValueCountAggregation  不会进行去重操作
Aggregation("tags", elastic.NewValueCountAggregation().Field("tags"))
//得到聚类结果和报错
cTag, _ := result.Aggregations.Cardinality("mytags")

//关键一步:值在*cTag.Value
//转成int64的原因是我们封装的返回方法需要而已
count := int64(*cTag.Value)
```

这里说明去重与否，我们来构造一组数据

```sh
[
	{tags:"python",content:"abc"},
	{tags:"hello",content:"hhh"},
	{tags:"python",content:"xxx"}
]
```

如果按照去重的标准，那么这里的总数就是 2，如果不去重就是条目总数，结果就是 3

#### 聚合分页后的标签列表接口

```go
package article_api

import (
	"context"
	"encoding/json"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

type TagsResponse struct {
	Tag           string   `json:"tag"`
	Count         int      `json:"count"`
	ArticleIDList []string `json:"articleIdList"`
}

type TagsType struct {
	DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
	SumOtherDocCount        int `json:"sum_other_doc_count"`
	Buckets                 []struct {
		Key      string `json:"key"`
		DocCount int    `json:"doc_count"`
		Articles struct {
			DocCountErrorUpperBound int `json:"doc_count_error_upper_bound"`
			SumOtherDocCount        int `json:"sum_other_doc_count"`
			Buckets                 []struct {
				Key      string `json:"key"`
				DocCount int    `json:"doc_count"`
			} `json:"buckets"`
		} `json:"articles"`
	} `json:"buckets"`
}

func (ArticleApi) ArticleTagListView(c *gin.Context) {
	var cr models.PageInfo
	_ = c.ShouldBindQuery(&cr)

	if cr.Limit == 0 {
		cr.Limit = 10
	}
	offset := (cr.Page - 1) * cr.Limit
	if offset < 0 {
		offset = 0
	}

	//获取总数，由于上下文的存在，所以求取总数在这里做，不受后续聚类或分页影响
	result, err := global.ESClient.
		Search(models.ArticleModel{}.Index()).
		Aggregation("tags", elastic.NewValueCountAggregation().Field("tags")).
		Size(0).
		Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	cTag, _ := result.Aggregations.Cardinality("tags")
	count := int64(*cTag.Value)

	//按照tags标签聚类
	agg := elastic.NewTermsAggregation().Field("tags")

	//添加一个子聚类，在之前聚类的基础上，根据keyword再次分组
	agg.SubAggregation("articles", elastic.NewTermsAggregation().Field("keyword"))
	// agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(offset).Size(cr.Limit))
	//分页操作
	agg.SubAggregation("page", elastic.NewBucketSortAggregation().From(offset).Size(cr.Limit))
	query := elastic.NewBoolQuery()

	result, err = global.ESClient.
		Search(models.ArticleModel{}.Index()).
		Query(query).
		Aggregation("tags", agg).
		Size(0).
		Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	var tagType TagsType
	var tagList = make([]TagsResponse, 0)
	_ = json.Unmarshal(result.Aggregations["tags"], &tagType)
	for _, bucket := range tagType.Buckets {

		var articleList []string
		for _, s := range bucket.Articles.Buckets {
			articleList = append(articleList, s.Key)
		}

		tagList = append(tagList, TagsResponse{
			Tag:           bucket.Key,
			Count:         bucket.DocCount,
			ArticleIDList: articleList,
		})
	}

	res.OkWithList(tagList, count, c)
}
```

### 标签表于文章标签的关联

```go
1.我们建立有一个标签表，文章添加的时候所选的标签列表就是从标签表中读取的
2.在有一些项目中要求删除标签其下的文章也应该删除，但是个人认为，一篇文章对应多个标签所以这种操作没必要

所以在我的项目中，标签就只有一个筛选文章的作用，相当于归类分组。
```

## 文章更新

文章更新的一些问题考虑

```sh
1.按照id更新数据是没有问题的
2.但是我们还有一个根据文章标题查询文章的接口，如果标题被修改就需要同步修改keyword
```

**完整代码**

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"time"

	"github.com/fatih/structs"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

type ArticleUpdateRequest struct {
	Title    string   `json:"title" structs:"title"`     // 文章标题
	Abstract string   `json:"abstract" structs:"abstract"`  // 文章简介
	Content  string   `json:"content" structs:"content"`   // 文章内容
	Category string   `json:"category" structs:"category"`  // 文章分类
	Source   string   `json:"source" structs:"source"`    // 文章来源
	Link     string   `json:"link" structs:"link"`      // 原文链接
	BannerID uint     `json:"bannerId" structs:"banner_id"` // 文章封面id
	Tags     []string `json:"tags" structs:"tags"`      // 文章标签
	ID       string   `json:"id" structs:"id"`
}

func (ArticleApi) ArticleUpdateView(c *gin.Context) {
	var cr ArticleUpdateRequest
	err := c.ShouldBindJSON(&cr)

	if err != nil {
		global.Log.Error(err)
		res.FailWithError(err, &cr, c)
		return
	}
	fmt.Printf("得到的json数据为%#v\n",cr)
	var bannerUrl string
	if cr.BannerID != 0 {
		err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
		if err != nil {
			res.FailWithMessage("banner不存在", c)
			return
		}
	}

	article := models.ArticleModel{
		UpdatedAt: time.Now().Format("2006-01-02 15:04:05"),
		Title:     cr.Title,
		Keyword:   cr.Title,
		Abstract:  cr.Abstract,
		Content:   cr.Content,
		Category:  cr.Category,
		Source:    cr.Source,
		Link:      cr.Link,
		BannerID:  cr.BannerID,
		BannerUrl: bannerUrl,
		Tags:      cr.Tags,
	}
    // fmt.Printf("结构体数据为%#v\n",article)
	//这里要转map的主要原因，我们json是驼峰格式，而es中是蛇形命名
	maps := structs.Map(&article)
	// fmt.Printf("获得的map值为%#v",maps)
	//要根据不同类型移除空值，因为structs会把没有值的键都采用零值
	var DataMap = map[string]any{}
	// 去掉空值
	for key, v := range maps {
		switch val := v.(type) {
		case string:
			if val == "" {
				continue
			}
		case uint:
			if val == 0 {
				continue
			}
		case int:
			if val == 0 {
				continue
			}
		case ctype.Array:
			if len(val) == 0 {
				continue
			}
		case []string:
			if len(val) == 0 {
				continue
			}
		}
		DataMap[key] = v
	}
	fmt.Printf("去掉空值的map值为%#v",DataMap)

	_, err = global.ESClient.
		Update().
		Index(models.ArticleModel{}.Index()).
		Id(cr.ID).
		Doc(DataMap).
		Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		res.FailWithMessage("更新失败", c)
		return
	}
	res.OkWithMessage("更新成功", c)
}
```

### **关于空值问题**

我们在这里面有一段非常复杂的空值处理，就是一旦字段没有改动就不让他在 map 中出现，也试过 json 过滤和 structs 过滤，可惜都不能实现，希望未来能找到好方法，目前只能如此操作

```go
maps := structs.Map(&article)
	// fmt.Printf("获得的map值为%#v",maps)
	//要根据不同类型移除空值，因为structs会把没有值的键都采用零值
	var DataMap = map[string]any{}
	// 去掉空值
	for key, v := range maps {
		switch val := v.(type) {
		case string:
			if val == "" {
				continue
			}
		case uint:
			if val == 0 {
				continue
			}
		case int:
			if val == 0 {
				continue
			}
		case ctype.Array:
			if len(val) == 0 {
				continue
			}
		case []string:
			if len(val) == 0 {
				continue
			}
		}
		DataMap[key] = v
	}
	fmt.Printf("去掉空值的map值为%#v",DataMap)
```

这里用于判断的类型主要来自结构体

```go
type ArticleUpdateRequest struct {
	Title    string   `json:"title" structs:"title"`     // 文章标题
	Abstract string   `json:"abstract" structs:"abstract"`  // 文章简介
	Content  string   `json:"content" structs:"content"`   // 文章内容
	Category string   `json:"category" structs:"category"`  // 文章分类
	Source   string   `json:"source" structs:"source"`    // 文章来源
	Link     string   `json:"link" structs:"link"`      // 原文链接
	BannerID uint     `json:"bannerId" structs:"banner_id"` // 文章封面id
	Tags     []string `json:"tags" structs:"tags"`      // 文章标签
	ID       string   `json:"id" structs:"id"`
}
```

### 关于 title 与 keyword 的问题

我们在上述代码中的处理方案是

```go
article := models.ArticleModel{
		UpdatedAt: time.Now().Format("2006-01-02 15:04:05"),
		Title:     cr.Title,
		Keyword:   cr.Title,
		Abstract:  cr.Abstract,
		Content:   cr.Content,
		Category:  cr.Category,
		Source:    cr.Source,
		Link:      cr.Link,
		BannerID:  cr.BannerID,
		BannerUrl: bannerUrl,
		Tags:      cr.Tags,
}
```

等效处理方案如下

```go
//如果我们不在结构体里多加字段，可以采用这种
if _,ok := DataMap["title"];ok{
		DataMap["keyword"] = DataMap["title"]
}
```

### 补充校验

我们在更新前应该先检测文章是否存在，封装方法

```go
func (a *ArticleModel) GetDataByID(id string) error {
	res, err := global.ESClient.
		Get().
		Index(a.Index()).
		Id(id).
		Do(context.Background())
	if err != nil {
		return err
	}
	err = json.Unmarshal(res.Source, a)
	return err
}
```

修改后的代码为

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"time"

	"github.com/fatih/structs"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

type ArticleUpdateRequest struct {
	Title    string   `json:"title" structs:"title"`     // 文章标题
	Abstract string   `json:"abstract" structs:"abstract"`  // 文章简介
	Content  string   `json:"content" structs:"content"`   // 文章内容
	Category string   `json:"category" structs:"category"`  // 文章分类
	Source   string   `json:"source" structs:"source"`    // 文章来源
	Link     string   `json:"link" structs:"link"`      // 原文链接
	BannerID uint     `json:"bannerId" structs:"banner_id"` // 文章封面id
	Tags     []string `json:"tags" structs:"tags"`      // 文章标签
	ID       string   `json:"id" structs:"id"`
}

func (ArticleApi) ArticleUpdateView(c *gin.Context) {
	var cr ArticleUpdateRequest
	err := c.ShouldBindJSON(&cr)

	if err != nil {
		global.Log.Error(err)
		res.FailWithError(err, &cr, c)
		return
	}
	fmt.Printf("得到的json数据为%#v\n",cr)
	var bannerUrl string
	if cr.BannerID != 0 {
		err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
		if err != nil {
			res.FailWithMessage("banner不存在", c)
			return
		}
	}

	article := models.ArticleModel{
		UpdatedAt: time.Now().Format("2006-01-02 15:04:05"),
		Title:     cr.Title,
		Keyword:   cr.Title,
		Abstract:  cr.Abstract,
		Content:   cr.Content,
		Category:  cr.Category,
		Source:    cr.Source,
		Link:      cr.Link,
		BannerID:  cr.BannerID,
		BannerUrl: bannerUrl,
		Tags:      cr.Tags,
	}
    // fmt.Printf("结构体数据为%#v\n",article)




	//这里要转map的主要原因，我们json是驼峰格式，而es中是蛇形命名
	maps := structs.Map(&article)
	// fmt.Printf("获得的map值为%#v",maps)
	//要根据不同类型移除空值，因为structs会把没有值的键都采用零值
	var DataMap = map[string]any{}
	// 去掉空值
	for key, v := range maps {
		switch val := v.(type) {
		case string:
			if val == "" {
				continue
			}
		case uint:
			if val == 0 {
				continue
			}
		case int:
			if val == 0 {
				continue
			}
		case ctype.Array:
			if len(val) == 0 {
				continue
			}
		case []string:
			if len(val) == 0 {
				continue
			}
		}
		DataMap[key] = v
	}
	// fmt.Printf("去掉空值的map值为%#v",DataMap)

    //更新前应该检测文章是否存在
	err = article.GetDataByID(cr.ID)
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("文章不存在", c)
		return
	}

    
    
	_, err = global.ESClient.
		Update().
		Index(models.ArticleModel{}.Index()).
		Id(cr.ID).
		Doc(DataMap).
		Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		res.FailWithMessage("更新失败", c)
		return
	}
	res.OkWithMessage("更新成功", c)
}
```

## 文章删除

只要采用 es 的 api 的删除即可

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

type IDListRequest struct {
	IDList []string `json:"idList"`
}

func (ArticleApi) ArticleRemoveView(c *gin.Context) {
	var cr IDListRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		global.Log.Error(err)
		res.FailWithCode(res.ArgumentError, c)
		return
	}

	bulkService := global.ESClient.Bulk().Index(models.ArticleModel{}.Index()).Refresh("true")
	for _, id := range cr.IDList {
		req := elastic.NewBulkDeleteRequest().Id(id)
		bulkService.Add(req)
	}
	result, err := bulkService.Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("删除失败", c)
		return
	}
	res.OkWithMessage(fmt.Sprintf("成功删除 %d 篇文章", len(result.Succeeded())), c)
}
```

这里暂时不考虑文章是否存在的问题，未来研究一下 es 的事务(?有吗)

## 问题总结

### 文章添加的问题

我在做聚合分析的时候，发现`created_at`字段聚合不到数据，`createdAt`提示类型错误，原因

**model 层**

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword,omit(list)" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content,omit(list)" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

**mapping**

我们用这个来初始化了索引

```go
func (ArticleModel) Mapping() string {
	return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text"
      },
      "keyword": {
        "type": "keyword"
      },
      "abstract": {
        "type": "text"
      },
      "content": {
        "type": "text"
      },
      "look_count": {
        "type": "integer"
      },
      "comment_count": {
        "type": "integer"
      },
      "upvote_count": {
        "type": "integer"
      },
      "collects_count": {
        "type": "integer"
      },
      "user_id": {
        "type": "integer"
      },
      "user_nick_name": {
        "type": "keyword"
      },
      "user_avatar": {
        "type": "keyword"
      },
      "category": {
        "type": "keyword"
      },
      "source": {
        "type": "keyword"
      },
      "link": {
        "type": "keyword"
      },
      "banner_id": {
        "type": "integer"
      },
      "banner_url": {
        "type": "keyword"
      },
      "tags": {
        "type": "keyword"
      },
      "created_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      },
      "updated_at":{
        "type": "date",
        "null_value": "null",
        "format": "[yyyy-MM-dd HH:mm:ss]"
      }
    }
  }
}
`
}
```

**插入时的操作**

```go
func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))

	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistData(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}

// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(a).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

问题的来源就在`Create`方法这里,

```sh
1.ArticleCreateView方法中调用Create时插入的是json，此时字段映射是驼峰形式的，我们直接使用BodyJson插入时就把驼峰形式插入进去，又由于es遇到不存在的键名会直接给他text类型，所以实际上创建的是updatedAt、bannerId、createdAt等，且都是text类型数据。

2.Mapping初始化索引就相当于建表，但是由于es的易扩展性，所以不具备强制约束和对应关系，这也就是为什么我们插入updatedAt等的时候只会新加字段而不会与update_at进行关联。
```

**报错记录**

```sh
Text fields are not optimised for operations that require per-document field data like aggregations and sorting, so these operations are disabled by default. Please use a keyword field instead. Alternatively, set fielddata=true on [updatedAt] in order to load field data by uninverting the inverted index. Note that this can use significant memory
```

这是我们对`updatedAt`做聚类时报的错，指的是我们不能对 text 类型做时间聚类，因为 updateAt 是 es 自动根据我们插入的内容扩展的，默认类型为 text。

**解决方案**

在插入 es 前，将 json 用 map 改造，

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword,omit(list)" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content,omit(list)" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

改造成 map 再插入

```go
// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	maps := structs.Map(&a)
	fmt.Printf("map值为%#v",maps)
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(maps).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

#### 小结

```sh
1.es和mysql的本质区别，es是文档类型的，实际上不具备表结构，所以非常容易扩展，我们习惯性存入键值对类型，但es遇到陌生键的时候会自动扩展，且赋予text类型。

2.es的键命名，es和mysql不一样，实际上es的键可以是蛇形，也可以是驼峰，我们使用蛇形只是因为使用习惯。
```

### json-filter 与 structs 包冲突

对于如下 model

```go
//json中的omit和select是来自json-filter包的，警告可忽略
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `json:"keyword,omit(list)" structs:"keyword"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `json:"content,omit(list)" structs:"content"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```

我们在做 map 转化时发现，凡是使用 json-filter 方法的 json 映射，在 structs 映射中首字母都被大写了，例如

```sh
Keyword、Content
```

解决方案，将 json 映射放到 structs 映射后面

```go
type ArticleModel struct {
	ID        string `json:"id" structs:"id"`                 // es的id
	CreatedAt string `json:"createdAt" structs:"created_at"` // 创建时间
	UpdatedAt string `json:"updatedAt" structs:"updated_at"` // 更新时间

	Title    string `json:"title" structs:"title"`                // 文章标题
	Keyword  string `structs:"keyword" json:"keyword,omit(list)"` // 关键字
	Abstract string `json:"abstract" structs:"abstract"`          // 文章简介
	Content  string `structs:"content" json:"content,omit(list)"` // 文章内容

	LookCount     int `json:"lookCount" structs:"look_count"`         // 浏览量
	CommentCount  int `json:"commentCount" structs:"comment_count"`   // 评论量
	UpvoteCount     int `json:"upvoteCount" structs:"upvote_count"`         // 点赞量
	CollectsCount int `json:"collectsCount" structs:"collects_count"` // 收藏量

	UserID       uint   `json:"userId" structs:"user_id"`               // 用户id
	UserNickName string `json:"userNickName" structs:"user_nick_name"` //用户昵称
	UserAvatar   string `json:"userAvatar" structs:"user_avatar"`       // 用户头像

	Category string `json:"category" structs:"category"`        // 文章分类
	Source   string `json:"source" structs:"source"` // 文章来源
	Link     string `json:"link" structs:"link"`     // 原文链接

	BannerID  uint   `json:"bannerId" structs:"banner_id"`   // 文章封面id
	BannerUrl string `json:"bannerUrl" structs:"banner_url"` // 文章封面

	Tags ctype.Array `json:"tags" structs:"tags"` // 文章标签
}
```
