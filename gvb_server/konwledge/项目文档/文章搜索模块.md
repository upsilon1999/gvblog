# 前言

这一个模块本来也属于文章管理，但是涉及的点太多了，所以拿出来讲，大致有如下内容

```sh
可根据排序搜索
根据标签搜索
根据文章标题搜索   标题需要高亮
根据文章正文搜索
根据文章简介搜索
```

正因为搜索的重要性，所以采用了elasticSearch

# 高亮搜索

## 如何实现es高亮

高亮的实现方案很多，

```sh
1.前端遍历内容进行高亮，但是这样遇到的问题就是，如果只是在文章标题中高亮尚可应对，可是文章内容或简介中高亮就意味着前端要对拿到的数据整体进行扫描，性能耗损极大，加载效果也会变慢

2.使用es实现高亮效果，他会对我们搜索时提出的高亮内容进行改变，例如我们搜title为"hello"的，那么他就会返回`<em>hello<em>其他`,前端只需要给em加样式即可
```

### Elasticsearch高亮

>一个参考网站:`https://dunwu.github.io/blog/`

```go
Elasticsearch 的高亮（highlight）可以让您从搜索结果中的一个或多个字段中获取突出显示的摘要，以便向用户显示查询匹配的位置。
当您请求突出显示（即高亮）时，响应结果的 highlight 字段中包括高亮的字段和高亮的片段。
Elasticsearch 默认会用 <em></em> 标签标记关键字。
```

**高亮参数**

ES 提供了如下高亮参数：

| 参数                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `boundary_chars`          | 包含每个边界字符的字符串。默认为,! ?\ \ n。                  |
| `boundary_max_scan`       | 扫描边界字符的距离。默认为 20。                              |
| `boundary_scanner`        | 指定如何分割突出显示的片段，支持 chars、sentence、word 三种方式。 |
| `boundary_scanner_locale` | 用来设置搜索和确定单词边界的本地化设置，此参数使用语言标记的形式（“en-US”, “fr-FR”, “ja-JP”） |
| `encoder`                 | 表示代码段应该是 HTML 编码的:默认(无编码)还是 HTML (HTML-转义代码段文本，然后插入高亮标记) |
| `fields`                  | 指定检索高亮显示的字段。可以使用通配符来指定字段。例如，可以指定 comment**来获取以 comment*开头的所有文本和关键字字段的高亮显示。 |
| `force_source`            | 根据源高亮显示。默认值为 false。                             |
| `fragmenter`              | 指定文本应如何在突出显示片段中拆分:支持参数 simple 或者 span。 |
| `fragment_offset`         | 控制要开始突出显示的空白。仅在使用 fvh highlighter 时有效。  |
| `fragment_size`           | 字符中突出显示的片段的大小。默认为 100。                     |
| `highlight_query`         | 突出显示搜索查询之外的其他查询的匹配项。这在使用重打分查询时特别有用，因为默认情况下高亮显示不会考虑这些问题。 |
| `matched_fields`          | 组合多个匹配结果以突出显示单个字段，对于使用不同方式分析同一字符串的多字段。所有的 matched_fields 必须将 term_vector 设置为 with_positions_offsets，但是只有将匹配项组合到的字段才会被加载，因此只有将 store 设置为 yes 才能使该字段受益。只适用于 fvh highlighter。 |
| `no_match_size`           | 如果没有要突出显示的匹配片段，则希望从字段开头返回的文本量。默认为 0(不返回任何内容)。 |
| `number_of_fragments`     | 返回的片段的最大数量。如果片段的数量设置为 0，则不会返回任何片段。相反，突出显示并返回整个字段内容。当需要突出显示短文本(如标题或地址)，但不需要分段时，使用此配置非常方便。如果 number_of_fragments 为 0，则忽略 fragment_size。默认为 5。 |
| `order`                   | 设置为 score 时，按分数对突出显示的片段进行排序。默认情况下，片段将按照它们在字段中出现的顺序输出(order:none)。将此选项设置为 score 将首先输出最相关的片段。每个高亮应用自己的逻辑来计算相关性得分。 |
| `phrase_limit`            | 控制文档中所考虑的匹配短语的数量。防止 fvh highlighter 分析太多的短语和消耗太多的内存。提高限制会增加查询时间并消耗更多内存。默认为 256。 |
| `pre_tags`                | 与 post_tags 一起使用，定义用于突出显示文本的 HTML 标记。默认情况下，突出显示的文本被包装在和标记中。指定为字符串数组。 |
| `post_tags`               | 与 pre_tags 一起使用，定义用于突出显示文本的 HTML 标记。默认情况下，突出显示的文本被包装在和标记中。指定为字符串数组。 |
| `require_field_match`     | 默认情况下，只突出显示包含查询匹配的字段。将 require_field_match 设置为 false 以突出显示所有字段。默认值为 true。 |
| `tags_schema`             | 设置为使用内置标记模式的样式。                               |
| `type`                    | 使用的高亮模式，可选项为**_`unified`***、***`plain`***或***`fvh`_**。默认为 _`unified`_。 |

**自定义高亮片段**

如果我们想使用自定义标签，在高亮属性中给需要高亮的字段加上 `pre_tags` 和 `post_tags` 即可。例如，搜索 title 字段中包含关键词 javascript 的书籍并使用自定义 HTML 标签高亮关键词，查询语句如下：

```json
GET /books/_search
{
  "query": {
    "match": { "title": "javascript" }
  },
  "highlight": {
    "fields": {
      "title": {
        "pre_tags": ["<strong>"],
        "post_tags": ["</strong>"]
      }
    }
  }
}
```

**多字段高亮**

关于搜索高亮，还需要掌握如何设置多字段搜索高亮。比如，搜索 title 字段的时候，我们期望 description 字段中的关键字也可以高亮，这时候就需要把 `require_field_match` 属性的取值设置为 `fasle`。`require_field_match` 的默认值为 `true`，只会高亮匹配的字段。多字段高亮的查询语句如下：

```json
GET /books/_search
{
  "query": {
    "multi_match": { 
        "query":"nodejs",
        "fields":["title","abstract"] 
    }
  },
  "highlight": {
    "require_field_match": false,
    "fields": {
      "title": {},
      "abstract": {},
      "content":{}
    }
  }
}
```

**高性能分析**

Elasticsearch 提供了三种高亮器，分别是**默认的 highlighter 高亮器**、**postings-highlighter 高亮器**和 **fast-vector-highlighter 高亮器**。

默认的 **highlighter** 是最基本的高亮器。highlighter 高亮器实现高亮功能需要对 `_source` 中保存的原始文档进行二次分析，其速度在三种高亮器里最慢，优点是不需要额外的存储空间。

**postings-highlighter** 高亮器实现高亮功能不需要二次分析，但是需要在字段的映射中设置 `index_options` 参数的取值为 `offsets`，即保存关键词的偏移量，速度快于默认的 highlighter 高亮器。例如，配置 comment 字段使用 postings-highlighter 高亮器，映射如下：

```json
PUT /example
{
  "mappings": {
    "doc": {
      "properties": {
        "comment": {
          "type": "text",
          "index_options": "offsets"
        }
      }
    }
  }
}
```

**fast-vector-highlighter** 高亮器实现高亮功能速度最快，但是需要在字段的映射中设置 `term_vector` 参数的取值为 `with_positions_offsets`，即保存关键词的位置和偏移信息，占用的存储空间最大，是典型的空间换时间的做法。例如，配置 comment 字段使用 fast-vector-highlighter 高亮器，映射如下：

```json
PUT /example
{
  "mappings": {
    "doc": {
      "properties": {
        "comment": {
          "type": "text",
          "term_vector": "with_positions_offsets"
        }
      }
    }
  }
}
```

### elastic库实现高亮的语法

```go
result, err := client.
		Search(models.ArticleModel{}.Index()).//Search索引查询
		Query(elastic.NewMultiMatchQuery("node", "title", "abstract", "content")).//匹配多个搜索
		Highlight(elastic.NewHighlight().Field("title")).//高亮显示
		Size(100).
		Do(context.Background())
```

**NewMultiMatchQuery**

我们先来解析一下匹配多个搜索,源码

```go
func NewMultiMatchQuery(text interface{}, fields ...string) *MultiMatchQuery {
	q := &MultiMatchQuery{
		text:        text,
		fieldBoosts: make(map[string]*float64),
	}
	q.fields = append(q.fields, fields...)
	return q
}
```

第一个参数是要搜索的内容，后续的参数是被检索的字段

**Highlight**

指定高亮，查看源码

```go
func (s *SearchService) Highlight(highlight *Highlight) *SearchService {
	s.searchSource = s.searchSource.Highlight(highlight)
	return s
}
```

我们要高亮哪些内容就得构造出一个`*Highlight`实例，几个相关方法

1.构造实例

```go
func NewHighlight() *Highlight {
	hl := &Highlight{
		options: make(map[string]interface{}),
	}
	return hl
}
```

2.指定单个字段

```go
func (hl *Highlight) Field(name string) *Highlight {
	field := NewHighlighterField(name)
	hl.fields = append(hl.fields, field)
	return hl
}
```

3.指定多个字段

```go
func (hl *Highlight) Fields(fields ...*HighlighterField) *Highlight {
	hl.fields = append(hl.fields, fields...)
	return hl
}
```

4.自定义前缀

```go
func (hl *Highlight) PreTags(preTags ...string) *Highlight {
	hl.preTags = append(hl.preTags, preTags...)
	return hl
}
```

5.自定义后缀

```go
func (hl *Highlight) PostTags(postTags ...string) *Highlight {
	hl.postTags = append(hl.postTags, postTags...)
	return hl
}
```

**单字段测试内容**

```go
func TestHighLight(t *testing.T) {
	//连接es
	client, err := Connect()
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
	}

	/*
		NewMultiMatchQuery(要搜索的内容,被搜索字段1,被搜索字段2,...)
		elastic.NewHighlight().Field(要高亮的字段名)
		elastic.NewHighlight().Fields(要高亮的字段1,要高亮的字段2,要高亮的字段3,...)
	*/
	result, err := client.
		Search(models.ArticleModel{}.Index()).
		Query(elastic.NewMultiMatchQuery("node", "title", "abstract", "content")).
		Highlight(elastic.NewHighlight().Field("title")).
		Size(100).
		Do(context.Background())
	if err != nil {
		logrus.Error(err)
		return
	}

	for _, hit := range result.Hits.Hits {
		fmt.Println(string(hit.Source))
		fmt.Println(hit.Highlight)
	}
}
```

结果展示

```sh
#hit.Highlight
map[title:[<em>node</em>基础]]
```

**多字段测试内容**

```go
package elasticSearch_test

import (
	"context"
	"fmt"
	"gvb_server/models"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func TestHighLight(t *testing.T) {
	//连接es
	client, err := Connect()
	if err != nil {
		logrus.Fatalf("es连接失败 %s", err.Error())
	}

	/*
		NewMultiMatchQuery(要搜索的内容,被搜索字段1,被搜索字段2,...)
		elastic.NewHighlight().Field(要高亮的字段名)
	*/
	//单字段高亮测试
	// result, err := client.
	// 	Search(models.ArticleModel{}.Index()).
	// 	Query(elastic.NewMultiMatchQuery("node", "title", "abstract", "content")).
	// 	Highlight(elastic.NewHighlight().Field("title")).
	// 	Size(100).
	// 	Do(context.Background())
	// if err != nil {
	// 	logrus.Error(err)
	// 	return
	// }


	//多字段高亮测试
	var title = elastic.NewHighlighterField("title")
	var abstract = elastic.NewHighlighterField("abstract")
	var content = elastic.NewHighlighterField("content")
	result, err := client.
		Search(models.ArticleModel{}.Index()).
		Query(elastic.NewMultiMatchQuery("nodejs", "title", "abstract", "content")).
		Highlight(elastic.NewHighlight().Fields(title,abstract,content)).
		Size(100).
		Do(context.Background())
	if err != nil {
		logrus.Error(err)
		return
	}


	for _, hit := range result.Hits.Hits {
		fmt.Println(string(hit.Source))
		fmt.Println(hit.Highlight)
	}
}
```

输出结果

```go
map[abstract:[<em>nodejs</em>是一门流行的后端语言] content:[## <em>nodejs</em>是一门流行的后端语言]]
```

**一个现象**

```sh
我输入node查不到abstract和content，输入no，title也查不到
通过查资料发现，可能是分词器和高亮类型的问题
```

## 实际应用

实际上es高亮应该被应用于文章列表接口，但是我为了保留原接口进行对比，所以单独写了个文章高亮列表接口

```sh
该接口既包含员文章列表接口的功能，又加入了高亮功能
```

封装高亮查询方法

```go
//获取分页并高亮显示特定内容
func CommHighLightList(key string, page int, limit int)(list []models.ArticleModel,count int,err error){
	boolSearch := elastic.NewBoolQuery()
	from := page
	if key != "" {
	  boolSearch.Must(
		//构造多字段查询
		elastic.NewMultiMatchQuery(key, "title", "abstract", "content"),
	  )
	}
	if limit == 0 {
	  limit = 10
	}
	if from == 0 {
	  from = 1
	}


	var title = elastic.NewHighlighterField("title")
	var abstract = elastic.NewHighlighterField("abstract")
	var content = elastic.NewHighlighterField("content")
	res, err := global.ESClient.
    Search(models.ArticleModel{}.Index()).
    Query(boolSearch).
	Highlight(elastic.NewHighlight().Fields(title,abstract,content)).
    From((from - 1) * limit).
    Size(limit).
    Do(context.Background())

	if err != nil {
		logrus.Error(err.Error())
		return nil,0,err
	}

	count = int(res.Hits.TotalHits.Value) //搜索到结果总条数
	demoList := []models.ArticleModel{}
	for _,hit := range res.Hits.Hits{
		var model models.ArticleModel
		data,err := hit.Source.MarshalJSON()
		if err!=nil{
			logrus.Error(err.Error())
			continue
		}

		err = json.Unmarshal(data,&model)
		if err!=nil{
			logrus.Error(err)
		}
		model.ID = hit.Id 
		demoList = append(demoList, model)
	}
	fmt.Println(demoList,count)
	return demoList,count,err
}
```

接口使用

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
	"github.com/liu-cn/json-filter/filter"
)

func (ArticleApi) ArticleHighListView(c *gin.Context) {
	var cr models.PageInfo
	err := c.ShouldBindQuery(&cr)
	if err != nil {
	  res.FailWithCode(res.ArgumentError, c)
	  return
	}
	list,count,err := es_ser.CommHighLightList(cr.Key,cr.Page,cr.Limit)
	if err != nil{
		global.Log.Error(err)
		res.FailWithMessage("查询失败",c)
	}
	res.OkWithList(filter.Omit("list", list),int64(count),c)
}
```

## 用option形式封装

```go
```



