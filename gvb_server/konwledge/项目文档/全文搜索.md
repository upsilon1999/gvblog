## 概念

我们在检索的时候通过某个关键字对系统的所有文章进行搜索，基本需要展示为

```sh
文章标题
文章内容
```

然后需要点击跳转到对应文章，即跳转连接，所以前端至少要得到三个东西

```go
type SearchData struct {
  Body  string `json:"body"`  // 正文
  Slug  string `json:"slug"`  // 包含文章的id 的跳转地址，前端可以拼接他
  Title string `json:"title"` // 标题
}
```

## 原理

构造如下形式的数据

```json
{
    "?id=标题1": {
        "body": "标题下的正文内容",
        "slug": "标题1的跳转路径",
        "title": "标题1"
    },
    "?id=标题2": {
        "body": "标题下的正文内容",
        "slug": "标题2的跳转路径",
        "title": "标题2"
    }
}
```

**例子**

````go
## 环境搭建

拉取镜像

```Python
docker pull elasticsearch:7.12.0
```



创建docker容器挂在的目录：

```Python
mkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins

chmod 777 /opt/elasticsearch/data

```

配置文件

```Python
echo "http.host: 0.0.0.0" >> /opt/elasticsearch/config/elasticsearch.yml
```



创建容器

```Python
# linux
docker run --name es -p 9200:9200  -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms84m -Xmx512m" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0
```



访问ip:9200能看到东西

![](http://python.fengfengzhidao.com/pic/20230129212040.png)

就说明安装成功了



浏览器可以下载一个 `Multi Elasticsearch Head` es插件



第三方库

```Go
github.com/olivere/elastic/v7
```

## es连接

```Go
func EsConnect() *elastic.Client  {
  var err error
  sniffOpt := elastic.SetSniff(false)
  host := "http://127.0.0.1:9200"
  c, err := elastic.NewClient(
    elastic.SetURL(host),
    sniffOpt,
    elastic.SetBasicAuth("", ""),
  )
  if err != nil {
    logrus.Fatalf("es连接失败 %s", err.Error())
  }
  return c
}
```
````

我们要将上面的markdown解析成如下形式

```sh
{
    "?id=标题1": {
        "body": "标题下的正文内容",
        "slug": "标题1的跳转路径",
        "title": "标题1"
    },
    "?id=标题2": {
        "body": "标题下的正文内容",
        "slug": "标题2的跳转路径",
        "title": "标题2"
    }
}
```

**逻辑**

遇到`#`就是标题，直到下一个中间夹杂着内容的`#`出现,于是就有了标准形式

```sh
# 标题
内容
# 标题
内容
```

但也有些文章是特殊的，他不以标题开头，而是直接以内容开头，例如

```sh
内容1
# 标题
内容
```

这样我们直接搜内容1就定位不到，所以统一给一个文章标题，例如

```sh
# 文章标题
# 标题
内容
# 标题
内容

# 文章标题
内容
# 标题
内容
```

## 全文搜索算法实现

```go
package elasticSearch_test

import (
	"fmt"
	"strings"
	"testing"
)

func TestFullText(t *testing.T) {

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	// var headList,bodyList []string
	for _,str := range dataList{
		/*
			实际上这样会错误捕获到两种情况
			情形1:#123中间无空格 
			对应解决方案使用正则，例如 #{1,6} *

			情形2：
			# 在代码块中的注释
            对应解决方案，判断是否是代码块，如果是就不纳入

            但是捕获到他们对我们的目的影响不大
            因为我们就是要构造全文搜索的标题
        */
		
        if strings.HasPrefix(str,"#"){
            fmt.Println(str)
        }
    }
 }
```
**逻辑解析**

```
1.将要解析的数据转成字符串形式
2.按照换行符进行截取
3.然后对每行进行判断，如果是#号开头就是标题，反之是正文,这里有两个问题
```
虽然捕获到他们对我们的目的影响不大,因为我们就是要构造全文搜索的标题，但我们还是可以提供一些解决方案，例如对代码块代码进行过滤

### 处理代码块中的注释

```go
package elasticSearch_test

import (
	"fmt"
	"strings"
	"testing"
)

func TestFullText(t *testing.T) {

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	// var headList,bodyList []string
	for _,str := range dataList{
		/*
			实际上这样会错误捕获到两种情况
			情形1:#123中间无空格 
			对应解决方案使用正则，例如 #{1,6} *

			情形2：
			# 在代码块中的注释
			对应解决方案，判断是否是代码块，如果是就不纳入

			但是捕获到他们对我们的目的影响不大
			因为我们就是要构造全文搜索的标题
		*/
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
			fmt.Println(str)
		}
	}
}
```

**逻辑解析**

例如我们分割成了以下字符串

```sh
1. # 环境变量
2. ```python
3.#linux
4.```
5.hello world!!
```

观察代码

```go
var isCode bool = false
for _,str := range dataList{
    if strings.HasPrefix(str, "```") {
        isCode = !isCode
    }
    if strings.HasPrefix(str,"#")&&!isCode{
        fmt.Println(str)
    }
}
```

遍历到`2`时，isCode变为了true，直到`4`重新取反为false，所以成功跳过了代码块

### 将获取到的标题和数组组成列表

```go
package elasticSearch_test

import (
	"fmt"
	"strings"
	"testing"
)

func TestFullText(t *testing.T) {

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	var headList,bodyList []string
	var body string
	for _,str := range dataList{
		
		//移除代码块的影响
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
			headList = append(headList, str)
			if strings.TrimSpace(body) != "" {
				bodyList = append(bodyList, body)
			}
			body = ""
			continue
		}
		body += str
	}
	bodyList = append(bodyList, body)
	fmt.Println(headList)
	fmt.Println(len(bodyList))
	fmt.Println(bodyList[1])
}
```

注意我们这里实际上过滤了内容为空的标题

### 全文搜索的处理

#### **标题的处理**

我们目前获取到的标题为`# xx`或者`## xxx`，实际搜索时我们是不要前面的`#`的，例如

```go
func getHead(str string) string{
	//将#号替换为空格
	head := strings.ReplaceAll(str,"#","")
	//将所有空格移除
	head = strings.ReplaceAll(head," ","")
	return head
}
```

使用

```go
func TestFullText(t *testing.T) {

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	var headList,bodyList []string
	var body string
	for _,str := range dataList{
		
		//移除代码块的影响
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
            //储存格式化后的head
			headList = append(headList, getHead(str))
			if strings.TrimSpace(body) != "" {
				bodyList = append(bodyList, body)
			}
			body = ""
			continue
		}
		body += str
	}
	bodyList = append(bodyList, body)
}
```

#### **对文章主体的处理**

将文章解析成格式化后的markdown字符串，保证输入输出一致

```go
func getBody(str string) string{
	unsafe := blackfriday.MarkdownCommon([]byte(str))
	doc,_ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	fmt.Println(doc.Text())
	return doc.Text()
}
```

使用

```go
func TestFullText(t *testing.T) {

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	var headList,bodyList []string
	var body string
	for _,str := range dataList{
		
		//移除代码块的影响
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
			headList = append(headList, getHead(str))
			if strings.TrimSpace(body) != "" {
				bodyList = append(bodyList, getBody(body))
			}
			body = ""
			continue
		}
		body += str
	}
	bodyList = append(bodyList, getBody(body))
}
```

#### **前后端交互格式**

由于最终前端需要的格式为

```go
//非哈希路由
{
    "?id=标题1": {
        "body": "标题下的正文内容",
        "slug": "标题1的跳转路径",
        "title": "标题1"
    }
}

//hash路由，多了个#号
{
    "?id=#标题1": {
        "body": "标题下的正文内容",
        "slug": "标题1的跳转路径",
        "title": "标题1"
    }
}
```

所以构造

```go
type SearchData struct {
  Body  string `json:"body"`  // 正文
  Slug  string `json:"slug"`  // 包含文章的id 的跳转地址
  Title string `json:"title"` // 标题
}
```

又由于我们需要构造如下格式，

```sh
# 文章标题
# 标题
内容
# 标题
内容
```

所以我们需要加入文章标题，

**添加文章标题**

```go
package elasticSearch_test

import (
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

func getHead(str string) string{
	//将#号替换为空格
	head := strings.ReplaceAll(str,"#","")
	//将所有空格移除
	head = strings.ReplaceAll(head," ","")
	//构造出#标题的形式,适用于hash路由
	return "#"+head
}

func getBody(str string) string{
	unsafe := blackfriday.MarkdownCommon([]byte(str))
	doc,_ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	fmt.Println(doc.Text())
	return doc.Text()
}

func TestFullText(t *testing.T) {
	

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	var headList,bodyList []string
	var body string
	//加一个文章标题，应该由前端传入
	headList = append(headList, "文章标题")

	for _,str := range dataList{
		
		//移除代码块的影响
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
			headList = append(headList, getHead(str))
			if strings.TrimSpace(body) != "" {
				bodyList = append(bodyList, getBody(body))
			}
			body = ""
			continue
		}
		body += str
	}
	bodyList = append(bodyList, getBody(body))
	fmt.Println(headList)
	fmt.Println(len(bodyList))
	fmt.Println(bodyList[1])
}
```

**构造返回格式**

一个调整

```go
#文章标题
## 标题1
```

由于文章标题与我们实际标题之间可能不存在内容，所以在构造文章体的时候要把判空去除

```go
if strings.HasPrefix(str,"#")&&!isCode{
    headList = append(headList, getHead(str))
    //if strings.TrimSpace(body) != "" {
        bodyList = append(bodyList, getBody(body))
    //}
    body = ""
    continue
}
```

然后构造我们需要的返回格式

```go
package elasticSearch_test

import (
	"encoding/json"
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/russross/blackfriday"
)

type SearchData struct {
	Body  string `json:"body"`  // 正文
	Slug  string `json:"slug"`  // 包含文章的id 的跳转地址
	Title string `json:"title"` // 标题
}

func getHead(str string) string{
	//将#号替换为空格
	head := strings.ReplaceAll(str,"#","")
	//将所有空格移除
	head = strings.ReplaceAll(head," ","")
	//构造出#标题的形式,适用于hash路由
	return head
}

//构造hash路由
func getSlug(slug string) string {
	return "#" + slug
}

func getBody(str string) string{
	unsafe := blackfriday.MarkdownCommon([]byte(str))
	doc,_ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	fmt.Println(doc.Text())
	return doc.Text()
}

func TestFullText(t *testing.T) {
	

	//要解析的数据
	data:="## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
	//1.对数据按行进行切割
	dataList := strings.Split(data,"\n")
	var isCode bool = false
	//2.然后对每行进行判断，如果是#号开头就是标题，反之是正文
	var headList,bodyList []string
	var body string
	//加一个文章标题，应该由前端传入
	headList = append(headList, "文章标题")

	for _,str := range dataList{
		
		//移除代码块的影响
		if strings.HasPrefix(str, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(str,"#")&&!isCode{
			headList = append(headList, getHead(str))
			// if strings.TrimSpace(body) != "" {
				bodyList = append(bodyList, getBody(body))
			// }
			body = ""
			continue
		}
		body += str
	}
	bodyList = append(bodyList, getBody(body))
	
    
    //构造前后端交互格式
	var searchDataList []SearchData
	//文章的id，未来也由前端传入
	id := "/article/asdxxccvv"
	ln := len(headList)
	for i := 0; i < ln; i++ {
	  searchDataList = append(searchDataList, SearchData{
		Title: headList[i],
		Body:  bodyList[i],
		Slug:  id + getSlug(headList[i]),
	  })
	}
	b, _ := json.Marshal(searchDataList)
	fmt.Println(string(b))
	fmt.Println(searchDataList)
}
```

#### 抽离成非测试方法

```go
func main() {
  var data = "## 环境搭建\n\n拉取镜像\n\n```Python\ndocker pull elasticsearch:7.12.0\n```\n\n\n\n创建docker容器挂在的目录：\n\n```Python\nmkdir -p /opt/elasticsearch/config & mkdir -p /opt/elasticsearch/data & mkdir -p /opt/elasticsearch/plugins\n\nchmod 777 /opt/elasticsearch/data\n\n```\n\n配置文件\n\n```Python\necho \"http.host: 0.0.0.0\" >> /opt/elasticsearch/config/elasticsearch.yml\n```\n\n\n\n创建容器\n\n```Python\n# linux\ndocker run --name es -p 9200:9200  -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms84m -Xmx512m\" -v /opt/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /opt/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.12.0\n```\n\n\n\n访问ip:9200能看到东西\n\n![](http://python.fengfengzhidao.com/pic/20230129212040.png)\n\n就说明安装成功了\n\n\n\n浏览器可以下载一个 `Multi Elasticsearch Head` es插件\n\n\n\n第三方库\n\n```Go\ngithub.com/olivere/elastic/v7\n```\n\n## es连接\n\n```Go\nfunc EsConnect() *elastic.Client  {\n  var err error\n  sniffOpt := elastic.SetSniff(false)\n  host := \"http://127.0.0.1:9200\"\n  c, err := elastic.NewClient(\n    elastic.SetURL(host),\n    sniffOpt,\n    elastic.SetBasicAuth(\"\", \"\"),\n  )\n  if err != nil {\n    logrus.Fatalf(\"es连接失败 %s\", err.Error())\n  }\n  return c\n}\n```"
  
    
    
    //调用方法
    //第一个参数是前端路由
    GetSearchIndexDataByContent("/article/hd893bxGHD84", "es的环境搭建", data)
}

type SearchData struct {
  Body  string `json:"body"`  // 正文
  Slug  string `json:"slug"`  // 包含文章的id 的跳转地址
  Title string `json:"title"` // 标题
}

func GetSearchIndexDataByContent(id, title, content string) (searchDataList []SearchData) {
  dataList := strings.Split(content, "\n")
  var isCode bool = false
  var headList, bodyList []string
  var body string
  headList = append(headList, getHeader(title))
  for _, s := range dataList {
    // #{1,6}
    // 判断一下是否是代码块
    if strings.HasPrefix(s, "```") {
      isCode = !isCode
    }
    if strings.HasPrefix(s, "#") && !isCode {
      headList = append(headList, getHeader(s))
      //if strings.TrimSpace(body) != "" {
      bodyList = append(bodyList, getBody(body))
      //}
      body = ""
      continue
    }
    body += s
  }
  bodyList = append(bodyList, getBody(body))
  ln := len(headList)
  for i := 0; i < ln; i++ {
    searchDataList = append(searchDataList, SearchData{
      Title: headList[i],
      Body:  bodyList[i],
      Slug:  id + getSlug(headList[i]),
    })
  }
  b, _ := json.Marshal(searchDataList)
  fmt.Println(string(b))
  return searchDataList
}

func getHeader(head string) string {
  head = strings.ReplaceAll(head, "#", "")
  head = strings.ReplaceAll(head, " ", "")
  return head
}

func getBody(body string) string {
  unsafe := blackfriday.MarkdownCommon([]byte(body))
  doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
  return doc.Text()
}

func getSlug(slug string) string {
  return "#" + slug
}
```

## 同步数据到es

我们需要给每篇文章构造一个全文搜索，

```sh
1.文章的增删改查都需要同步全文搜索
```

### 构建model

我们也用es来存储，所以先构造es需要的model

```go
package models

import (
	"context"
	"gvb_server/global"

	"github.com/sirupsen/logrus"
)

type FullTextModel struct {
	ID    string `json:"id" structs:"id"`       // es的id
	Key   string `json:"key"`                   // 文章关联的id
	Title string `json:"title" structs:"title"` // 文章标题
	Slug  string `json:"slug" structs:"slug"`   // 标题的跳转地址
	Body  string `json:"body" structs:"body"`   // 文章内容
}

func (FullTextModel) Index() string {
	return "full_text_index"
}

func (FullTextModel) Mapping() string {
	return `
{
  "settings": {
    "index":{
      "max_result_window": "100000"
    }
  }, 
  "mappings": {
    "properties": {
	  "key": {
        "type": "keyword"
      },
      "title": { 
        "type": "text",
		"analyzer": "ik_max_word",
		"search_analyzer": "ik_smart"
      },
      "slug": { 
        "type": "keyword"
      },
      "body": { 
        "type": "text",
		"analyzer": "ik_max_word",
		"search_analyzer": "ik_smart"
      }
    }
  }
}
`
}

// IndexExists 索引是否存在
func (a FullTextModel) IndexExists() bool {
	exists, err := global.ESClient.
		IndexExists(a.Index()).
		Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return exists
	}
	return exists
}

// CreateIndex 创建索引
func (a FullTextModel) CreateIndex() error {
	if a.IndexExists() {
		// 有索引
		a.RemoveIndex()
	}
	// 没有索引
	// 创建索引
	createIndex, err := global.ESClient.
		CreateIndex(a.Index()).
		BodyString(a.Mapping()).
		Do(context.Background())
	if err != nil {
		logrus.Error("创建索引失败")
		logrus.Error(err.Error())
		return err
	}
	if !createIndex.Acknowledged {
		logrus.Error("创建失败")
		return err
	}
	logrus.Infof("索引 %s 创建成功", a.Index())
	return nil
}

// RemoveIndex 删除索引
func (a FullTextModel) RemoveIndex() error {
	logrus.Info("索引存在，删除索引")
	// 删除索引
	indexDelete, err := global.ESClient.DeleteIndex(a.Index()).Do(context.Background())
	if err != nil {
		logrus.Error("删除索引失败")
		logrus.Error(err.Error())
		return err
	}
	if !indexDelete.Acknowledged {
		logrus.Error("删除索引失败")
		return err
	}
	logrus.Info("索引删除成功")
	return nil
}
```

### **数据同步的逻辑**

#### 添加数据到全文搜索

现在我们书写将文章数据同步到es的逻辑

```go
package elasticSearch_test

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/models"
	"gvb_server/service/es_ser"
	"testing"

	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
)

func TestSyncFullText(t *testing.T) {
	client,err := Connect()
	if err !=nil{
		logrus.Fatalf("es连接失败 %s", err.Error())
	}
	boolSearch := elastic.NewMatchAllQuery()
	res, _ := client.
	  Search(models.ArticleModel{}.Index()).
	  Query(boolSearch).
	  Size(1000).
	  Do(context.Background())
	
	for _, hit := range res.Hits.Hits {
	  var article models.ArticleModel
	  _ = json.Unmarshal(hit.Source, &article)
	
	  indexList := es_ser.GetSearchIndexDataByContent(hit.Id, article.Title, article.Content)
	
	  bulk :=client.Bulk()
	  for _, indexData := range indexList {
		req := elastic.NewBulkIndexRequest().Index(models.FullTextModel{}.Index()).Doc(indexData)
		bulk.Add(req)
	  }
	  result, err := bulk.Do(context.Background())
	  if err != nil {
		logrus.Error(err)
		continue
	  }
	  fmt.Println(article.Title, "添加成功", "共", len(result.Succeeded()), " 条！")
	}
}
```

**批量添加**

这里用的es知识点是批量添加

```go
// 创建一个桶
bulk := global.ESClient.Bulk()
for _, indexData := range indexList {
  req := elastic.NewBulkIndexRequest().Index(models.FullTextModel{}.Index()).Doc(indexData)
  bulk.Add(req)
}
result, err := bulk.Do(context.Background())
```

#### 从全文搜索删除数据

为了能够删除全文搜索，我们应该在添加的时候加入关联id，例如

```go
type SearchData struct {
	Key   string `json:"key"` //文章关联id
	Body  string `json:"body"`  // 正文
	Slug  string `json:"slug"`  // 包含文章的id 的跳转地址
	Title string `json:"title"` // 标题
}
```

删除的实现

```go
// DeleteFullTextByArticleID 删除文章数据
func DeleteFullTextByArticleID(id string) {
  boolSearch := elastic.NewTermQuery("key", id)
  res, _ := global.ESClient.
    DeleteByQuery().
    Index(models.FullTextModel{}.Index()).
    Query(boolSearch).
    Do(context.Background())
  //如果id所代表的数据不存在也不会报错，而是删除0条
  logrus.Infof("成功删除 %d 条记录", res.Deleted)
}
```



### 在service层实现

```go
package es_ser

import (
	"context"
	"encoding/json"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/olivere/elastic/v7"
	"github.com/russross/blackfriday"
	"github.com/sirupsen/logrus"
)

type SearchData struct {
	Key   string `json:"key"` //文章关联id
	Body  string `json:"body"`  // 正文
	Slug  string `json:"slug"`  // 包含文章的id 的跳转地址
	Title string `json:"title"` // 标题
}

//构造全文搜索
func GetSearchIndexDataByContent(id, title, content string) (searchDataList []SearchData) {
	dataList := strings.Split(content, "\n")
	var isCode bool = false
	var headList, bodyList []string
	var body string
	headList = append(headList, getHeader(title))
	for _, s := range dataList {
		// #{1,6}
		// 判断一下是否是代码块
		if strings.HasPrefix(s, "```") {
			isCode = !isCode
		}
		if strings.HasPrefix(s, "#") && !isCode {
			headList = append(headList, getHeader(s))
			//if strings.TrimSpace(body) != "" {
			bodyList = append(bodyList, getBody(body))
			//}
			body = ""
			continue
		}
		body += s
	}
	bodyList = append(bodyList, getBody(body))
	ln := len(headList)
	for i := 0; i < ln; i++ {
		searchDataList = append(searchDataList, SearchData{
			Title: headList[i],
			Body:  bodyList[i],
			Slug:  id + getSlug(headList[i]),
			Key: id,
		})
	}
	b, _ := json.Marshal(searchDataList)
	fmt.Println(string(b))
	return searchDataList
}

func getHeader(head string) string {
	head = strings.ReplaceAll(head, "#", "")
	head = strings.ReplaceAll(head, " ", "")
	return head
}

func getBody(body string) string {
	unsafe := blackfriday.MarkdownCommon([]byte(body))
	doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	return doc.Text()
}

func getSlug(slug string) string {
	return "#" + slug
}



//通过全文搜索到es
//第一版设定这个会抛出错误，然后文章添加时会阻塞
//第二版设定，这个会提示错误，但是不抛出错误，不干扰文章的创建，在文章添加时使用协程
func AysncFullText(id, title, content string){
	  //创建全文搜索内容
	  indexList := GetSearchIndexDataByContent(id, title, content)
	
	  bulk :=global.ESClient.Bulk()
	  for _, indexData := range indexList {
		req := elastic.NewBulkIndexRequest().Index(models.FullTextModel{}.Index()).Doc(indexData)
		bulk.Add(req)
	  }
	  result, err := bulk.Do(context.Background())
	  if err != nil {
		logrus.Error(err)
		// return err
	  }
	  logrus.Infof( "%s添加成功, 共%d条", title, len(result.Succeeded()))
	//   return nil
}

//删除全文搜索
// DeleteFullTextByArticleID 删除全文搜索数据
func DeleteFullTextByArticleID(id string) {
	boolSearch := elastic.NewTermQuery("key", id)
	res, _ := global.ESClient.
	  DeleteByQuery().
	  Index(models.FullTextModel{}.Index()).
	  Query(boolSearch).
	  Do(context.Background())
	//如果id所代表的数据不存在也不会报错，而是删除0条
	logrus.Infof("成功删除 %d 条记录", res.Deleted)
}
```

抛出错误的文章同步版本

```go
//通过全文搜索到es
func AysncFullText(id, title, content string) error{
	  //创建全文搜索内容
	  indexList := GetSearchIndexDataByContent(id, title, content)
	
	  bulk :=global.ESClient.Bulk()
	  for _, indexData := range indexList {
		req := elastic.NewBulkIndexRequest().Index(models.FullTextModel{}.Index()).Doc(indexData)
		bulk.Add(req)
	  }
	  result, err := bulk.Do(context.Background())
	  if err != nil {
		logrus.Error(err)
		return err
	  }
	  logrus.Infof( "%s添加成功, 共%d条", title, len(result.Succeeded()))
	  return nil
}
```

### 在文章增删改查的接口中使用

全文搜索的同步应该和文章相关联

```sh
1. 发布文章  同步创建全文搜索数据
2. 文章更新  判断文章标题和文章内容是否有变化
3. 文章删除	 同步删除全文搜索数据
```



#### 文章添加

在添加文章时创建全文搜索

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
	
	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistTitle(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}


	//在创建文章时创建全文搜索
	err = es_ser.AysncFullText(article.ID,article.Title,article.Content)
    if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}
	res.OkWithMessage("文章发布成功", c)
}
```

一个值得注意的点，

```go
es_ser.AysncFullText(article.ID,article.Title,article.Content)
```

此处之所以能使用`article.ID`,是因为我们使用了指针

```go
// Create 添加文章的方法
func (a *ArticleModel) Create() (err error) {
	indexResponse, err := global.ESClient.Index().
		Index(a.Index()).
		BodyJson(a).Do(context.Background())
	if err != nil {
		logrus.Error(err.Error())
		return err
	}
	a.ID = indexResponse.Id
	return nil
}
```

**拆分关联**

如果我们不想要全文搜索干扰到文章的添加，可以不让全文搜索报错，同时使用协程

```go
//通过全文搜索到es
func AysncFullText(id, title, content string){
	  //创建全文搜索内容
	  indexList := GetSearchIndexDataByContent(id, title, content)
	
	  bulk :=global.ESClient.Bulk()
	  for _, indexData := range indexList {
		req := elastic.NewBulkIndexRequest().Index(models.FullTextModel{}.Index()).Doc(indexData)
		bulk.Add(req)
	  }
	  result, err := bulk.Do(context.Background())
	  if err != nil {
		logrus.Error(err)
	  }
	  logrus.Infof( "%s添加成功, 共%d条", title, len(result.Succeeded()))
}
```

使用协程

```go
package article_api

import (
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"
	jwts "gvb_server/utils/jwt"
	"strings"
	"time"

	"math/rand"

	md "github.com/JohannesKaufmann/html-to-markdown"
	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
	"github.com/russross/blackfriday"
)

func (ArticleApi) ArticleCreateView(c *gin.Context){
	//登录后从token拿去用户数据
	var cr ArticleRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		res.FailWithError(err, &cr, c)
		return
	}
	_claims, _ := c.Get("claims")
	claims := _claims.(*jwts.CustomClaims)
	userID := claims.UserID
	userNickName := claims.NickName
	//对文章内容content的处理
	/*
		要进行xxs过滤:
		1.把前端传递来的markdown形式content转成html
		2.进行xxs过滤后再转回markdown，方便前端回显
	*/
	 // 处理content，把markdown转为html
	 unsafe := blackfriday.MarkdownCommon([]byte(cr.Content))
	
	 doc, _ := goquery.NewDocumentFromReader(strings.NewReader(string(unsafe)))
	 //fmt.Println(doc.Text())
	 // 是不是有script标签
	 nodes := doc.Find("script").Nodes
	 //如果有script标签就过滤掉然后再将过滤后结果转回markdown
	 if len(nodes) > 0 {
	   // 有script标签
	   doc.Find("script").Remove()
	   converter := md.NewConverter("", true, nil)
	   html, _ := doc.Html()
	   markdown, _ := converter.ConvertString(html)
	   cr.Content = markdown
	 }




	// 对文章简介的处理
	// 如果文章简介没传，就默认选文章内容的前30个字符
	if cr.Abstract == "" {
		// 汉字的截取不一样
		abs := []rune(doc.Text())
		// 将content转为html，并且过滤xss，以及获取中文内容
		if len(abs) > 100 {
		  cr.Abstract = string(abs[:100])
		} else {
		  cr.Abstract = string(abs)
		}
	  }

	// 不传banner_id,后台就随机去选择一张
	//当我们不传时将采用零值
	if cr.BannerID == 0 {
		var bannerIDList []uint
		global.DB.Model(models.BannerModel{}).Select("id").Scan(&bannerIDList)
		if len(bannerIDList) == 0 {
			res.FailWithMessage("没有banner数据", c)
			return
		}

		//go 1.22设立随机源
		//然后调用随机源上的方法
		r:=rand.New(rand.NewSource(time.Now().UnixNano()))
		// fmt.Println("随机数生成",r.Intn(20))
		cr.BannerID = bannerIDList[r.Intn(len(bannerIDList))]
	}
	// 查banner_id下的banner_url
	var bannerUrl string
	err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
	if err != nil {
		res.FailWithMessage("banner不存在", c)
		return
	}

	// 查用户头像
	var avatar string
	err = global.DB.Model(models.UserModel{}).Where("id = ?", userID).Select("avatar").Scan(&avatar).Error
	if err != nil {
		res.FailWithMessage("用户不存在", c)
		return
	}


	//发布文章
	//获取当前时间并格式化
	now := time.Now().Format("2006-01-02 15:04:05")
	article := models.ArticleModel{
		CreatedAt:    now,
		UpdatedAt:    now,
		Title:        cr.Title,
		Keyword: cr.Title,//这一步是必要的，否则es中keyword就无值
		Abstract:     cr.Abstract,
		Content:      cr.Content,
		UserID:       userID,
		UserNickName: userNickName,
		UserAvatar:   avatar,
		Category:     cr.Category,
		Source:       cr.Source,
		Link:         cr.Link,
		BannerID:     cr.BannerID,
		BannerUrl:    bannerUrl,
		Tags:         cr.Tags,
	}

	//在创建es文章数据前，对keyword进行判断
	if article.ISExistTitle(){
		res.FailWithMessage("文章已存在",c)
		return
	}

	err = article.Create()
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage(err.Error(), c)
		return
	}


	//在创建文章时开启协程来创建全文搜索
	go es_ser.AysncFullText(article.ID,article.Title,article.Content)
    
	res.OkWithMessage("文章发布成功", c)
}
```

#### 文章更新

```sh
基本逻辑:
先删除与文章关联的全文搜索记录,然后再添加

处理思路:
1. 发布文章
2. 文章更新  判断文章标题和文章内容是否有变化
3. 文章删除
```

文章更新的代码

```go
package article_api

import (
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/ctype"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"
	"time"

	"github.com/fatih/structs"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
)

type ArticleUpdateRequest struct {
	Title    string   `json:"title" structs:"title"`     // 文章标题
	Abstract string   `json:"abstract" structs:"abstract"`  // 文章简介
	Content  string   `json:"content" structs:"content"`   // 文章内容
	Category string   `json:"category" structs:"category"`  // 文章分类
	Source   string   `json:"source" structs:"source"`    // 文章来源
	Link     string   `json:"link" structs:"link"`      // 原文链接
	BannerID uint     `json:"bannerId" structs:"bannerId"` // 文章封面id
	Tags     []string `json:"tags" structs:"tags"`      // 文章标签
	ID       string   `json:"id" structs:"id"`
}

func (ArticleApi) ArticleUpdateView(c *gin.Context) {
	var cr ArticleUpdateRequest
	err := c.ShouldBindJSON(&cr)
	
	if err != nil {
		global.Log.Error(err)
		res.FailWithError(err, &cr, c)
		return
	}
	fmt.Printf("得到的json数据为%#v\n",cr)
	var bannerUrl string
	if cr.BannerID != 0 {
		err = global.DB.Model(models.BannerModel{}).Where("id = ?", cr.BannerID).Select("path").Scan(&bannerUrl).Error
		if err != nil {
			res.FailWithMessage("banner不存在", c)
			return
		}
	}

	article := models.ArticleModel{
		UpdatedAt: time.Now().Format("2006-01-02 15:04:05"),
		Title:     cr.Title,
		Keyword:   cr.Title,
		Abstract:  cr.Abstract,
		Content:   cr.Content,
		Category:  cr.Category,
		Source:    cr.Source,
		Link:      cr.Link,
		BannerID:  cr.BannerID,
		BannerUrl: bannerUrl,
		Tags:      cr.Tags,
	}
    fmt.Printf("结构体数据为%#v\n",article)


	//更新前应该检测文章是否存在
	// if article.ISExistDataById() {
	// 	global.Log.Error(err)
	// 	res.FailWithMessage("文章不存在", c)
	// 	return
	// }

	//这里转map的原因是为了移除空值
	//要根据不同类型移除空值，因为structs会把没有值的键都采用零值
	maps := structs.Map(&article)
	// fmt.Printf("获得的map值为%#v",maps)
	
	var DataMap = map[string]any{}
	// 去掉空值
	for key, v := range maps {
		switch val := v.(type) {
		case string:
			if val == "" {
				continue
			}
		case uint:
			if val == 0 {
				continue
			}
		case int:
			if val == 0 {
				continue
			}
		case ctype.Array:
			if len(val) == 0 {
				continue
			}
		case []string:
			if len(val) == 0 {
				continue
			}
		}
		DataMap[key] = v
	}
	fmt.Printf("去掉空值的map值为%#v\n",DataMap)

	//更新前应该检测文章是否存在
	
	err = article.GetDataByID(cr.ID)
	if  err!=nil{
		global.Log.Error(err)
		res.FailWithMessage("文章不存在", c)
		return
	}
	// fmt.Println(article)
	//由于指针的关系，article会拿到该id对应的旧的数据
	//而我们要更新的数据已经赋值给了DataMap，所以并不冲突

	err = es_ser.ArticleUpdate(cr.ID,DataMap)
	if err != nil {
		logrus.Error(err.Error())
		res.FailWithMessage("更新失败", c)
		return
	}

	//更新成功，同步数据到全文搜索
	//1.获取文章详情,此时得到的是更新后的文章详情
	newArticle,_ := es_ser.CommDetail(cr.ID)
	//2.与我们获取的到article旧数据做对比，如果标题或者内容不一样就更新全文搜索
	if article.Content != newArticle.Content||article.Title!=newArticle.Title{
		//先删除旧的记录，然后插入新记录
		es_ser.DeleteFullTextByArticleID(cr.ID)
		es_ser.AysncFullText(cr.ID,newArticle.Title,newArticle.Content)
	}

	res.OkWithMessage("更新成功", c)
}
```

**关键点**

```sh
1.用DataMap保留了新数据，使其不被干扰
2.err = article.GetDataByID(cr.ID)，这一步既是检测文章是否存在，也是通过指针把旧的文章数据赋值给article

3.更新后再次获取文章详情，然后与旧的作比较
```

**通过id获取文章详情的方法**

```go
func (a *ArticleModel) GetDataByID(id string) error {
	res, err := global.ESClient.
		Get().
		Index(a.Index()).
		Id(id).
		Do(context.Background())
	if err != nil {
		return err
	}
	err = json.Unmarshal(res.Source, a)
	return err
}
```

#### 文章删除

这里的同步很容易，因为我们本来就是按照es索引id来删除文章的，在删除文章时开启协程删除全文搜索即可

```go
package article_api

import (
	"context"
	"fmt"
	"gvb_server/global"
	"gvb_server/models"
	"gvb_server/models/res"
	"gvb_server/service/es_ser"

	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic/v7"
)

type IDListRequest struct {
	IDList []string `json:"idList"`
}

func (ArticleApi) ArticleRemoveView(c *gin.Context) {
	var cr IDListRequest
	err := c.ShouldBindJSON(&cr)
	if err != nil {
		global.Log.Error(err)
		res.FailWithCode(res.ArgumentError, c)
		return
	}

	bulkService := global.ESClient.Bulk().Index(models.ArticleModel{}.Index()).Refresh("true")
	for _, id := range cr.IDList {
		req := elastic.NewBulkDeleteRequest().Id(id)
		bulkService.Add(req)

		//同时删除全文搜索
		go es_ser.DeleteFullTextByArticleID(id)
	}
	result, err := bulkService.Do(context.Background())
	if err != nil {
		global.Log.Error(err)
		res.FailWithMessage("删除失败", c)
		return
	}
	res.OkWithMessage(fmt.Sprintf("成功删除 %d 篇文章", len(result.Succeeded())), c)
}
```

这里我们可以解决新的问题了

```sh
如果文章被删除了，用户收藏的这篇文章怎么办？
有两种方案可以选择
1.顺带把与这个文章关联的收藏也删除掉
2.用户收藏表，新增一个字段，表示文章是否删除，

第二个方法存在新问题:
用户可以删除这个收藏记录，但是找不到文章去修改收藏数
```







